---
title: "NestJS"
metadataTitle: "Usage with NestJS | xmcp Documentation"
publishedAt: "2025-07-06"
summary: "Learn how to integrate xmcp with your existing NestJS application."
description: "Plug xmcp into your existing NestJS application with automatic tool discovery, authentication support, and custom route configuration."
---

## Overview

The NestJS adapter allows you to integrate xmcp into your existing NestJS application. It provides:

- **Automatic tool discovery** from your `src/tools/` directory
- **NestJS-native patterns** using Guards and Decorators for authentication
- **Flexible routing** with the ability to use the default `/mcp` endpoint or create custom routes
- **OAuth 2.0 support** with Bearer token authentication

## Installation

`xmcp` can work on top of your existing NestJS project. To get started, run the following command in your project directory:

```bash
npx init-xmcp@latest
```

On initialization, you'll see the following prompts:

<TerminalPrompt>
  {
    "? Tools directory path: (tools)\n? Prompts directory path: (prompts)\n? Resources directory path: (resources)"
  }
</TerminalPrompt>

The package manager and framework will be detected automatically.

After setting up the project, update your `package.json` scripts:

```json title="package.json"
{
  "scripts": {
    "dev": "xmcp dev & nest start --watch",
    "build": "xmcp build && nest build",
    "start": "node dist/main.js"
  }
}
```

<Callout variant="info">
  Before using the `@xmcp/adapter` import, you need to:

  1. Run `npx xmcp build` to generate the `.xmcp` folder
  2. Update your `tsconfig.json` to include the path mapping and the `.xmcp` folder:

  ```json title="tsconfig.json"
  {
    "compilerOptions": {
      "paths": {
        "@xmcp/*": ["./.xmcp/*"]
      }
    },
    "include": ["src/**/*", "xmcp-env.d.ts", ".xmcp/**/*"]
  }
  ```

  After these steps, TypeScript errors will be resolved.
</Callout>

## Project Structure

After initialization, your project structure will look like this:

```
my-nestjs-app/
├── src/
│   ├── tools/              # Tool files are auto-discovered here
│   │   └── greet.ts
│   ├── prompts/            # Prompt files are auto-discovered here
│   │   └── review-code.ts
│   ├── resources/          # Resource files are auto-discovered here
│   │   └── config/app.ts
│   ├── app.module.ts       # Import XmcpModule here
│   └── main.ts
├── .xmcp/                  # Generated by xmcp build (gitignored)
├── xmcp.config.ts          # xmcp configuration
├── xmcp-env.d.ts           # Type declarations
├── package.json
└── tsconfig.json
```

### Generated Files

**`.xmcp/`** - Contains the compiled adapter module and auto-generated TypeScript definitions. This directory is created by `xmcp build` and should be added to `.gitignore`. It includes the `XmcpModule`, `XmcpService`, and all type definitions needed to integrate with NestJS.

**`xmcp-env.d.ts`** - Provides TypeScript type declarations for xmcp imports like `@xmcp/adapter`. This file is auto-generated and should not be edited manually. It ensures TypeScript can resolve the path alias configured in `tsconfig.json`.

## Basic Usage

Import and add the `XmcpModule` to your application module:

```typescript title="src/app.module.ts"
import { Module } from "@nestjs/common";
import { XmcpModule } from "@xmcp/adapter";

@Module({
  imports: [XmcpModule],
})
export class AppModule {}
```

This automatically registers a `/mcp` endpoint that handles MCP requests via POST.

## Configuration

Configure the NestJS adapter in your `xmcp.config.ts`:

```typescript title="xmcp.config.ts"
import { type XmcpConfig } from "xmcp";

const config: XmcpConfig = {
  http: true,
  experimental: {
    adapter: "nestjs",
  },
};

export default config;
```

The NestJS adapter uses HTTP transport and supports native NestJS patterns:

- **Guards** for authentication and authorization
- **Interceptors** for request/response transformation
- **Pipes** for input validation

These integrate with NestJS's dependency injection system, allowing you to inject services directly into your MCP controllers.

## Adding Tools

Tools are automatically discovered from your `src/tools/` directory. Create a new file and export a default handler function:

```typescript title="src/tools/greet.ts"
import { z } from "zod";
import { type InferSchema } from "xmcp";

export const schema = {
  name: z.string().describe("The name of the user to greet"),
};

export const metadata = {
  name: "greet",
  description: "Greet the user by name",
};

export default async function greet({ name }: InferSchema<typeof schema>) {
  return `Hello, ${name}!`;
}
```

When you run `xmcp dev` or `xmcp build`, xmcp automatically discovers this file and registers it as an MCP tool. No additional configuration needed.

<Callout variant="info">
  For more details on creating tools, schemas, and metadata, see the [Tools documentation](/docs/core-concepts/tools).
</Callout>

## Custom Routes

By default, `XmcpModule` automatically registers a `/mcp` POST endpoint with a built-in controller. If you need a custom route path or want to add authentication/middleware, you can disable this auto-registered route:

### Option 1: Using `XmcpCoreModule` (Recommended)

A dedicated service-only module that never registers any controllers—designed specifically for custom route scenarios:

```typescript title="src/app.module.ts"
import { Module } from "@nestjs/common";
import { XmcpCoreModule } from "@xmcp/adapter";
import { CustomMcpController } from "./mcp/custom-mcp.controller";

@Module({
  imports: [XmcpCoreModule],
  controllers: [CustomMcpController],
})
export class AppModule {}
```

### Option 2: Using `XmcpModule.forRoot()`

Alternatively, use the full module but explicitly disable the built-in controller. Useful if you want to conditionally enable/disable the default controller:

```typescript title="src/app.module.ts"
import { Module } from "@nestjs/common";
import { XmcpModule } from "@xmcp/adapter";
import { CustomMcpController } from "./mcp/custom-mcp.controller";

@Module({
  imports: [XmcpModule.forRoot({ disableController: true })],
  controllers: [CustomMcpController],
})
export class AppModule {}
```

```typescript title="src/mcp/custom-mcp.controller.ts"
import { Controller, Post, Get, Options, Req, Res } from "@nestjs/common";
import { Request, Response } from "express";
import { XmcpService } from "@xmcp/adapter";

@Controller("api/v1/mcp") // Custom path
export class CustomMcpController {
  constructor(private readonly xmcpService: XmcpService) {}

  @Post()
  async handleMcp(@Req() req: Request, @Res() res: Response): Promise<void> {
    return this.xmcpService.handleRequest(req, res);
  }

  @Get()
  handleGet(@Res() res: Response): void {
    res.status(200).json({
      jsonrpc: "2.0",
      error: {
        code: -32000,
        message: "Method not allowed. MCP requires POST requests.",
      },
      id: null,
    });
  }

  @Options()
  handleOptions(@Res() res: Response): void {
    res.status(204).send();
  }
}
```

### When to Use Each

**Choose `XmcpCoreModule`** when you always want custom routes. It's a static module that never registers any controllers—cleaner and more explicit about your intent.

**Choose `XmcpModule.forRoot()`** when you need to conditionally toggle the default controller based on configuration or environment:

```typescript
XmcpModule.forRoot({
  disableController: process.env.USE_CUSTOM_ROUTES === 'true'
})
```

Both provide the same `XmcpService`—the difference is purely about whether and how the default `/mcp` controller gets registered.

## Authentication

Add OAuth 2.0 Bearer token authentication using the `@McpAuth` decorator:

```typescript title="src/mcp/secure-mcp.controller.ts"
import {
  Controller,
  Post,
  Get,
  Options,
  Req,
  Res,
} from "@nestjs/common";
import { Request, Response } from "express";
import {
  XmcpService,
  McpAuth,
  Auth,
  VerifyToken,
  AuthInfo,
} from "@xmcp/adapter";

const verifyToken: VerifyToken = async (
  req: Request,
  bearerToken?: string
): Promise<AuthInfo | undefined> => {
  if (!bearerToken) return undefined;

  // Replace with your actual token verification logic
  // Example: validate JWT, call auth service, etc.
  const isValid = await validateToken(bearerToken);

  if (!isValid) return undefined;

  return {
    token: bearerToken,
    clientId: "client-123",
    scopes: ["read:tools", "execute:tools"],
    extra: {
      userId: "user-456",
    },
  };
};

@Controller("mcp")
export class SecureMcpController {
  constructor(private readonly xmcpService: XmcpService) {}

  @Post()
  @McpAuth({
    verifyToken,
    required: true,
    requiredScopes: ["execute:tools"],
  })
  async handleMcp(
    @Auth() auth: AuthInfo,
    @Req() req: Request,
    @Res() res: Response
  ): Promise<void> {
    // auth contains the verified AuthInfo
    console.log('Client:', auth?.clientId);
    return this.xmcpService.handleRequest(req, res);
  }

  @Get()
  handleGet(@Res() res: Response): void {
    res.status(200).json({
      jsonrpc: "2.0",
      error: { code: -32000, message: "MCP requires POST requests." },
      id: null,
    });
  }

  @Options()
  handleOptions(@Res() res: Response): void {
    res.status(204).send();
  }
}
```

The `@McpAuth` decorator combines the guard and configuration in a single decorator, which is cleaner than using `@UseGuards(XmcpAuthGuard)` and `@XmcpAuth()` separately. The `@Auth()` parameter decorator extracts the authenticated user's info directly into a handler parameter.

<Callout variant="info">
  For more control, you can use the verbose approach with separate decorators:
  ```typescript
  import { UseGuards } from "@nestjs/common";
  import { XmcpAuthGuard, XmcpAuth } from "@xmcp/adapter";

  @Post()
  @UseGuards(XmcpAuthGuard)
  @XmcpAuth({ verifyToken, required: true })
  async handleMcp(@Req() req: Request, @Res() res: Response) {
    // req.auth contains the verified AuthInfo
  }
  ```
</Callout>

### Auth Configuration Options

- **`verifyToken`** (`VerifyToken`, required) - Function to verify the bearer token and return auth info
- **`required`** (`boolean`, default: `false`) - If `true`, requests without valid auth are rejected with 401
- **`requiredScopes`** (`string[]`, default: `[]`) - Scopes that must be present in the token

### AuthInfo Object

The `verifyToken` function should return an `AuthInfo` object on success:

```typescript
type AuthInfo = {
  token: string;           // The original bearer token
  clientId: string;        // Client identifier
  scopes: string[];        // Granted scopes
  expiresAt?: number;      // Token expiration (Unix timestamp)
  resource?: URL;          // Resource the token is valid for
  extra?: Record<string, unknown>; // Additional custom data
};
```

### Accessing Auth in Tools

When using authentication, you can access the authenticated user's information inside your tools using `getAuthInfo()`:

```typescript title="src/tools/get-profile.ts"
import { z } from "zod";
import { getAuthInfo, type InferSchema } from "xmcp";

export const schema = {};

export const metadata = {
  name: "get-profile",
  description: "Get the authenticated user's profile",
};

export default function getProfile({}: InferSchema<typeof schema>) {
  const auth = getAuthInfo();

  if (!auth) {
    return { error: "Not authenticated" };
  }

  const { clientId, scopes, extra } = auth;

  return {
    clientId,
    scopes,
    userId: extra?.userId,
  };
}
```

The `getAuthInfo()` function returns the same `AuthInfo` object that was returned by your `verifyToken` function, or `undefined` if the request is not authenticated.

## OAuth Protected Resource Metadata

To support OAuth 2.0 discovery ([RFC 9728](https://datatracker.ietf.org/doc/html/rfc9728)), add the `ResourceMetadataController`:

```typescript title="src/app.module.ts"
import { Module } from "@nestjs/common";
import {
  XmcpModule,
  ResourceMetadataController,
  AUTHORIZATION_SERVERS,
} from "@xmcp/adapter";

@Module({
  imports: [XmcpModule],
  controllers: [ResourceMetadataController],
  providers: [
    {
      provide: AUTHORIZATION_SERVERS,
      useValue: ["https://auth.example.com"],
    },
  ],
})
export class AppModule {}
```

This creates a `/.well-known/oauth-protected-resource` endpoint that MCP clients can use to discover your authorization server:

```json
{
  "resource": "https://your-server.com",
  "authorization_servers": ["https://auth.example.com"]
}
```

## Error Handling

Handle errors in your custom controllers using NestJS exception filters or by returning MCP-formatted error responses:

```typescript title="src/mcp/custom-mcp.controller.ts"
import { Controller, Post, Req, Res, HttpException, HttpStatus } from "@nestjs/common";
import { Request, Response } from "express";
import { XmcpService } from "@xmcp/adapter";

@Controller("mcp")
export class CustomMcpController {
  constructor(private readonly xmcpService: XmcpService) {}

  @Post()
  async handleMcp(@Req() req: Request, @Res() res: Response): Promise<void> {
    try {
      return await this.xmcpService.handleRequest(req, res);
    } catch (error) {
      // Return MCP-formatted error
      res.status(200).json({
        jsonrpc: "2.0",
        error: {
          code: -32603,
          message: error instanceof Error ? error.message : "Internal error",
        },
        id: req.body?.id ?? null,
      });
    }
  }
}
```

<Callout variant="info">
  MCP errors should return HTTP 200 with the error in the JSON-RPC response body. Use HTTP error codes (4xx/5xx) only for transport-level failures, not application errors.
</Callout>

## Troubleshooting

### Cannot find module '@xmcp/adapter'

This error occurs when the `.xmcp` directory hasn't been generated yet.

**Solution:** Run `npx xmcp build` before starting your NestJS application.

### TypeScript path resolution errors

If TypeScript can't resolve `@xmcp/*` imports:

1. Ensure `tsconfig.json` has the path mapping:
   ```json
   {
     "compilerOptions": {
       "paths": {
         "@xmcp/*": ["./.xmcp/*"]
       }
     }
   }
   ```

2. Ensure `.xmcp` is included in the `include` array:
   ```json
   {
     "include": ["src/**/*", "xmcp-env.d.ts", ".xmcp/**/*"]
   }
   ```

### Authentication not working

If `@Auth()` returns `undefined` or auth isn't being applied:

1. **Check decorator order** - `@McpAuth()` must be applied before `@Post()`:
   ```typescript
   @Post()
   @McpAuth({ verifyToken, required: true })  // ✓ Correct order
   async handleMcp() {}
   ```

2. **Verify the Authorization header** - Ensure the client sends `Authorization: Bearer <token>`

3. **Check verifyToken return value** - Return `undefined` for invalid tokens, not throwing errors

## Next Steps

<ConceptBoxes>
  <ConceptBox
    title="Tools"
    description="Learn how to create tools with schemas and metadata."
    href="/docs/core-concepts/tools"
  />
  <ConceptBox
    title="Prompts"
    description="Define reusable prompts for AI interactions."
    href="/docs/core-concepts/prompts"
  />
  <ConceptBox
    title="Resources"
    description="Expose data through queryable resources."
    href="/docs/core-concepts/resources"
  />
  <ConceptBox
    title="Authentication"
    description="Learn more about authentication patterns."
    href="/docs/authentication"
  />
</ConceptBoxes>
