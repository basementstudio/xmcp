---
title: "NestJS"
metadataTitle: "Usage with NestJS | xmcp Documentation"
publishedAt: "2025-07-06"
summary: "Learn how to integrate xmcp with your existing NestJS application."
description: "Plug xmcp into your existing NestJS application with automatic tool discovery and custom route configuration."
---

## Overview

The NestJS adapter allows you to integrate xmcp into your existing NestJS application. It provides:

- **Automatic tool discovery** from your `src/tools/` directory
- **Flexible routing** with the ability to use the default `/mcp` endpoint or create custom routes
- **NestJS integration** with `XmcpModule`, `XmcpService`, and `XmcpController`

## Installation

`xmcp` can work on top of your existing NestJS project. To get started, run the following command in your project directory:

```bash
npx init-xmcp@latest
```

On initialization, you'll see the following prompts:

<TerminalPrompt>
  {
    "? Tools directory path: (tools)"
  }
</TerminalPrompt>

The package manager and framework will be detected automatically.

After setting up the project, update your `package.json` scripts:

```json title="package.json"
{
  "scripts": {
    "dev": "xmcp dev & nest start --watch",
    "build": "xmcp build && nest build",
    "start": "node dist/main.js"
  }
}
```

<Callout variant="info">
  Before using the `@xmcp/adapter` import, you need to:

  1. Run `npx xmcp build` to generate the `.xmcp` folder
  2. Update your `tsconfig.json` to include the path mapping and the `.xmcp` folder:

  ```json title="tsconfig.json"
  {
    "compilerOptions": {
      "paths": {
        "@xmcp/*": ["./.xmcp/*"]
      }
    },
    "include": ["src/**/*", "xmcp-env.d.ts", ".xmcp/**/*"]
  }
  ```

  After these steps, TypeScript errors will be resolved.
</Callout>

## Project Structure

After initialization, your project structure will look like this:

```
my-nestjs-app/
├── src/
│   ├── tools/              # Tool files are auto-discovered here
│   │   └── greet.ts
│   ├── app.module.ts       # Import XmcpModule here
│   └── main.ts
├── .xmcp/                  # Generated by xmcp build (gitignored)
├── xmcp.config.ts          # xmcp configuration
├── xmcp-env.d.ts           # Type declarations
├── package.json
└── tsconfig.json
```

### Generated Files

**`.xmcp/`** - Contains the compiled adapter module and auto-generated TypeScript definitions. This directory is created by `xmcp build` and should be added to `.gitignore`. It includes the `XmcpModule`, `XmcpService`, and all type definitions needed to integrate with NestJS.

**`xmcp-env.d.ts`** - Provides TypeScript type declarations for xmcp imports like `@xmcp/adapter`. This file is auto-generated and should not be edited manually. It ensures TypeScript can resolve the path alias configured in `tsconfig.json`.

## Basic Usage

Import and add the `XmcpModule` to your application module:

```typescript title="src/app.module.ts"
import { Module } from "@nestjs/common";
import { XmcpModule } from "@xmcp/adapter";

@Module({
  imports: [XmcpModule],
})
export class AppModule {}
```

This automatically registers a `/mcp` endpoint that handles MCP requests via POST.

## Configuration

Configure the NestJS adapter in your `xmcp.config.ts`:

```typescript title="xmcp.config.ts"
import { type XmcpConfig } from "xmcp";

const config: XmcpConfig = {
  http: true,
  experimental: {
    adapter: "nestjs",
  },
};

export default config;
```

The NestJS adapter uses HTTP transport and integrates with NestJS's module system, allowing you to use the `XmcpService` in your custom controllers.

## NestJS Integration Features

The adapter provides full NestJS integration with proper lifecycle management and error handling:

### Lifecycle Hooks

`XmcpService` implements `OnModuleInit` and `OnModuleDestroy` for proper initialization and shutdown logging:

- **Startup**: Logs `[XmcpService] XMCP service initialized` when the module initializes
- **Shutdown**: Logs `[XmcpService] XMCP service shutting down` when the application stops

### Exception Filter

`XmcpExceptionFilter` provides consistent JSON-RPC error handling for MCP endpoints. It automatically:

- Logs errors with stack traces using NestJS `Logger`
- Returns properly formatted JSON-RPC error responses
- Handles cases where headers have already been sent

The filter is automatically applied to the default `XmcpController`. For custom controllers, apply it manually:

```typescript title="src/mcp/custom-mcp.controller.ts"
import { UseFilters } from "@nestjs/common";
import { XmcpController, XmcpControllerDecorator, XmcpExceptionFilter } from "@xmcp/adapter";

@XmcpControllerDecorator("api/v1/mcp")
@UseFilters(XmcpExceptionFilter)
export class CustomMcpController extends XmcpController {}
```

### Structured Logging

All XMCP internal logs use the NestJS `Logger` class, automatically inheriting your application's logging configuration.

### Health Checks

`XmcpHealthIndicator` integrates with `@nestjs/terminus` for production health monitoring:

```typescript
// health.controller.ts
import { Controller, Get } from "@nestjs/common";
import { HealthCheck, HealthCheckService } from "@nestjs/terminus";
import { XmcpHealthIndicator } from "@xmcp/adapter";

@Controller("health")
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private xmcpHealth: XmcpHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      () => this.xmcpHealth.isHealthy(),
    ]);
  }
}
```

Response example:
```json
{
  "status": "ok",
  "info": {
    "xmcp": { "status": "initialized" }
  }
}
```

## Adding Tools

Tools are automatically discovered from your `src/tools/` directory. Create a new file and export a default handler function:

```typescript title="src/tools/greet.ts"
import { z } from "zod";
import { type InferSchema } from "xmcp";

export const schema = {
  name: z.string().describe("The name of the user to greet"),
};

export const metadata = {
  name: "greet",
  description: "Greet the user by name",
};

export default async function greet({ name }: InferSchema<typeof schema>) {
  return `Hello, ${name}!`;
}
```

When you run `xmcp dev` or `xmcp build`, xmcp automatically discovers this file and registers it as an MCP tool. No additional configuration needed.

<Callout variant="info">
  For more details on creating tools, schemas, and metadata, see the [Tools documentation](/docs/core-concepts/tools).
</Callout>

## Custom Routes

By default, `XmcpModule` automatically registers a `/mcp` POST endpoint with a built-in controller. If you need a custom route path, you can extend the `XmcpController` and use the `XmcpControllerDecorator` to specify a custom path.

### Creating a Custom Controller

Extend `XmcpController` and apply `XmcpControllerDecorator` with your desired path. Include `XmcpExceptionFilter` to maintain consistent error handling:

```typescript title="src/mcp/custom-mcp.controller.ts"
import { UseFilters } from "@nestjs/common";
import { XmcpController, XmcpControllerDecorator, XmcpExceptionFilter } from "@xmcp/adapter";

@XmcpControllerDecorator("api/v1/mcp")
@UseFilters(XmcpExceptionFilter)
export class CustomMcpController extends XmcpController {}
```

### Using a Custom Module

Create a separate module that provides `XmcpService`, `XmcpExceptionFilter`, and registers your custom controller:

```typescript title="src/mcp/custom-route.module.ts"
import { Module } from "@nestjs/common";
import { XmcpService, XmcpExceptionFilter } from "@xmcp/adapter";
import { CustomMcpController } from "./custom-mcp.controller";

@Module({
  controllers: [CustomMcpController],
  providers: [XmcpService, XmcpExceptionFilter],
})
export class CustomRouteModule {}
```

Then import this module instead of `XmcpModule` in your app module:

```typescript title="src/app.module.ts"
import { Module } from "@nestjs/common";
import { CustomRouteModule } from "./mcp/custom-route.module";

@Module({
  imports: [CustomRouteModule],
})
export class AppModule {}
```

This will register your MCP endpoint at `/api/v1/mcp` instead of the default `/mcp`.

## Troubleshooting

### Cannot find module '@xmcp/adapter'

This error occurs when the `.xmcp` directory hasn't been generated yet.

**Solution:** Run `npx xmcp build` before starting your NestJS application.

### TypeScript path resolution errors

If TypeScript can't resolve `@xmcp/*` imports:

1. Ensure `tsconfig.json` has the path mapping:
   ```json
   {
     "compilerOptions": {
       "paths": {
         "@xmcp/*": ["./.xmcp/*"]
       }
     }
   }
   ```

2. Ensure `.xmcp` is included in the `include` array:
   ```json
   {
     "include": ["src/**/*", "xmcp-env.d.ts", ".xmcp/**/*"]
   }
   ```

## Next Steps

<ConceptBoxes>
  <ConceptBox
    title="Tools"
    description="Learn how to create tools with schemas and metadata."
    href="/docs/core-concepts/tools"
  />
  <ConceptBox
    title="Prompts"
    description="Define reusable prompts for AI interactions."
    href="/docs/core-concepts/prompts"
  />
  <ConceptBox
    title="Resources"
    description="Expose data through queryable resources."
    href="/docs/core-concepts/resources"
  />
</ConceptBoxes>
