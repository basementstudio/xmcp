---
title: "Authentication"
metadataTitle: "MCP Server Authentication Guide | xmcp Documentation"
publishedAt: "2026-01-16"
summary: "Learn how authentication works on MCP servers with human-based interaction."
description: "Secure your MCP server with OAuth 2.1 authentication. Learn about PKCE, JWT tokens, scopes, and token-based access control. Integrate with Better Auth, Clerk, or WorkOS."
displayTitle: "Authentication guide for MCP servers"
---

## Overview

MCP provides authorization capabilities at the transport level, enabling clients to make requests to restricted servers on behalf of resource owners. The authorization mechanism is based on OAuth 2.1 and implements several related standards.

## When do you need authentication?

Not every MCP server needs authentication. The decision depends on how your server is deployed and what it exposes.

**HTTP-based MCP servers** that are deployed remotely should implement authentication. When your server is accessible over the network, you need to verify who is making requests before granting access to tools and resources. This applies to servers deployed on platforms like Vercel, AWS, or any cloud provider, as well as self-hosted servers exposed to the internet.

**STDIO-based MCP servers** running locally on a user's machine typically don't need authentication. Since the server runs in the user's own environment with their permissions, the user is implicitly trusted. Instead of OAuth, these servers should retrieve any needed credentials from environment variables or local configuration files.

The key distinction is trust and exposure. A local STDIO server inherits trust from the user's operating system. A remote HTTP server is exposed to the network and must establish trust through authentication before processing requests.

## How MCP authentication works

MCP authentication is built on OAuth 2.1 with mandatory PKCE (Proof Key for Code Exchange). PKCE is a security extension that protects the authorization flow. This makes authentication secure even for public clients like desktop apps and CLI tools that cannot safely store long-term secrets.

![MCP Authentication Flow](https://j2fbnka41vq9pfap.public.blob.vercel-storage.com/images/auth-diagram.svg)

### Discovery

When an MCP client first connects to an authenticated server, it needs to discover where and how to authenticate. The client fetches metadata from well-known URLs that describe the authorization server and its capabilities.

The server exposes its authentication requirements at `/.well-known/oauth-protected-resource`, which tells clients where to find the authorization server. The authorization server then provides its endpoints at `/.well-known/oauth-authorization-server`, including where to send users for login and where to exchange tokens.

Servers can also indicate authentication requirements dynamically by returning a `401 Unauthorized` response with the metadata URL in the header:

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer resource_metadata="https://mcp.example.com/.well-known/oauth-protected-resource"
```

This approach is useful when the same server handles both authenticated and unauthenticated requests on different endpoints.

<Callout variant="info">
When discovering authorization server metadata, clients try multiple well-known paths in order. For a server at `https://auth.example.com/tenant1`:

1. `https://auth.example.com/.well-known/oauth-authorization-server/tenant1`
2. `https://auth.example.com/.well-known/openid-configuration/tenant1`
3. `https://auth.example.com/tenant1/.well-known/openid-configuration`

This fallback mechanism ensures compatibility with different authorization server configurations.
</Callout>

### Client registration

Before a client can authenticate users, it needs to identify itself to the authorization server. MCP supports three approaches:

**Client ID Metadata Documents** are the recommended approach. Clients host a JSON document at an HTTPS URL that describes their identity, name, and allowed redirect URIs. The URL itself becomes the client ID, eliminating the need for pre-registration.

A Client ID Metadata Document looks like this:

```json
{
  "client_id": "https://app.example.com/oauth/client-metadata.json",
  "client_name": "My MCP Client",
  "client_uri": "https://app.example.com",
  "redirect_uris": [
    "http://127.0.0.1:3000/callback",
    "http://localhost:3000/callback"
  ],
  "grant_types": ["authorization_code"],
  "response_types": ["code"],
  "token_endpoint_auth_method": "none"
}
```

The URL where this document is hosted becomes the client ID. Authorization servers that support this approach advertise `client_id_metadata_document_supported: true` in their metadata.

**Dynamic Client Registration** allows clients to register automatically by making a request to the authorization server. This creates a unique client ID for each installation.

**Pre-registration** is the traditional approach where client credentials are configured in advance, either hardcoded by the developer or entered by the user.

### User authentication

Once the client knows where to authenticate, it redirects the user to the authorization server's login page. The user signs in with their credentials and grants the client permission to access the MCP server on their behalf.

PKCE protects this flow by generating a unique code verifier for each authentication attempt. The client sends a hashed version of this verifier with the authorization request and proves possession of the original when exchanging the authorization code for tokens. This prevents attackers from intercepting and using authorization codes.

### Token-based access

After successful authentication, the client receives an access token. This token is included in every request to the MCP server via the `Authorization: Bearer` header. The server validates the token and extracts user information to authorize the request.

Tokens are bound to the specific MCP server using the `resource` parameter during authentication. This prevents tokens issued for one server from being used to access another, protecting against token confusion attacks.

### Scopes

Scopes define what an access token is allowed to do. They act as permissions that limit the capabilities of a token, even for an authenticated user.

When a client initiates authentication, it requests specific scopes like `read`, `write`, or `admin`. The authorization server includes the granted scopes in the access token. Your MCP server can then check these scopes before allowing certain operations.

Scopes are particularly useful when:
- Different clients need different permission levels
- You want to limit what third-party integrations can do
- Users should be able to grant partial access to their account

The MCP server advertises its supported scopes in the protected resource metadata, and clients can request specific scopes during the authorization flow.

For example, a token with only the `read` scope could access tools that fetch data but would be rejected when trying to use tools that modify data. This provides fine-grained access control beyond simple authentication.

When initiating authentication, clients determine which scopes to request using this priority order:

1. Use the `scope` parameter from the `WWW-Authenticate` header if the server provided one
2. Request all scopes listed in `scopes_supported` from the Protected Resource Metadata
3. Omit the scope parameter entirely if `scopes_supported` is not defined

This strategy ensures clients request appropriate permissions based on what the server advertises.

## Security requirements

The MCP specification mandates several security measures:

### PKCE is mandatory

All clients must implement PKCE with the `S256` code challenge method.

### Resource binding

Clients must include the `resource` parameter in authorization and token requests. This parameter identifies the MCP server the token is intended for.

The resource must be a valid canonical URI. Valid examples include:
- `https://mcp.example.com`
- `https://mcp.example.com/mcp`
- `https://mcp.example.com:8443`

Invalid examples include:
- `mcp.example.com` (missing scheme)
- `https://mcp.example.com#section` (contains fragment)
- `https://mcp.example.com?query=1` (contains query)

Servers must validate that tokens were issued specifically for them by checking the audience claim matches their canonical URI.

### HTTPS everywhere

All authorization server endpoints must use HTTPS.

### Token handling

- Access tokens must be sent via the `Authorization: Bearer` header
- Tokens must never be included in query strings
- Servers should issue short-lived access tokens
- Servers must not pass client tokens through to upstream APIs

## Security best practices

Beyond the mandatory requirements, these practices help protect your MCP server:

### Token storage

Store access tokens securely and never expose them in logs or error messages. Use short-lived tokens and implement token refresh to limit the impact of token theft.

### Redirect URI validation

Validate redirect URIs exactly as registered. Do not allow partial matches or wildcards. Support the OAuth `state` parameter to prevent CSRF attacks during the authorization flow.

### Token isolation

Never forward access tokens received from clients to upstream APIs or third-party services. Each service should issue and validate its own tokens.

### Client metadata validation

If your server fetches Client ID Metadata Documents, implement SSRF protections. Validate URLs before fetching and consider maintaining allowlists for trusted client domains.

## Error responses

- **401**: Authorization required or token invalid/expired
- **403**: Insufficient scopes for the requested operation
- **400**: Malformed authorization request

When a client has insufficient permissions, the server responds with:

```http
HTTP/1.1 403 Forbidden
WWW-Authenticate: Bearer error="insufficient_scope",
                         scope="files:read files:write",
                         resource_metadata="https://example.com/.well-known/oauth-protected-resource",
                         error_description="Additional permissions required"
```

### Step-up authorization

When a client receives an `insufficient_scope` error, it can request additional permissions without requiring the user to fully re-authenticate. This is called step-up authorization.

The flow works as follows:

1. **Parse the error** - Extract scope requirements from the `WWW-Authenticate` header
2. **Determine required scopes** - Combine existing scopes with the newly required ones
3. **Re-authorize** - Redirect the user to grant the additional permissions
4. **Retry the request** - Use the new token with expanded scopes

Clients should limit retry attempts to prevent infinite authorization loops when scopes cannot be granted.

## Available auth plugins

xmcp provides plugins that handle all the OAuth complexity for you.

<AuthProviders />

## Choosing an auth plugin

### Better Auth

Best for developers who want full control over their authentication infrastructure.

- Self-hosted with PostgreSQL database
- Built-in authentication UI included
- Email/password and social OAuth support
- Complete ownership of user data

### Clerk

Best for quick setup with minimal configuration.

- Hosted authentication UI
- Organization and team support
- SSO/SAML capabilities
- Managed infrastructure, no database needed

### WorkOS

Best for enterprise applications and B2B SaaS products.

- Hosted authentication UI via AuthKit
- Enterprise SSO and SAML
- Directory sync (SCIM) for user provisioning
- Organization and role management

## FAQ

<FAQ>
  <FAQItem question="Can I use my existing OAuth provider with MCP?">
    Yes. MCP's authentication is based on standard OAuth 2.1 and can work with any compliant authorization server. xmcp provides official plugins for Better Auth (self-hosted), Clerk, and WorkOS, but the protocol is compatible with other OAuth providers that support the required specifications.
  </FAQItem>

  <FAQItem question="What happens when a token expires?">
    When an access token expires, the MCP client receives a `401 Unauthorized` response. The client should then use its refresh token to obtain a new access token without requiring the user to log in again. If the refresh token is also expired, the user must re-authenticate through the full OAuth flow.
  </FAQItem>

  <FAQItem question="How do I protect specific tools with authentication?">
    Once authentication is configured on your MCP server, all tools are protected by default. The server validates the access token before processing any request. Within your tool handlers, you can access the authenticated user's session to implement additional authorization logic, such as restricting certain tools to specific users or roles.
  </FAQItem>

  <FAQItem question="What's the difference between authentication and authorization in MCP?">
    Authentication verifies who the user is through the OAuth flow. Authorization determines what the authenticated user is allowed to do. MCP handles authentication at the transport level, while authorization decisions happen in your tool handlers where you can check the user's session, roles, or permissions before executing operations.
  </FAQItem>

  <FAQItem question="What are scopes in MCP authentication?">
    Scopes are permissions that limit what an access token can do. When authenticating, clients request specific scopes like `read` or `write`. Your MCP server can check these scopes before allowing certain operations, enabling fine-grained access control. For example, you might allow a token with `read` scope to fetch data but reject it when trying to modify data.
  </FAQItem>

  <FAQItem question="What MCP clients support authentication?">
    Most modern MCP clients support OAuth 2.1 authentication, including Claude Desktop, Cursor, and other AI coding assistants. These clients handle the OAuth flow automatically, redirecting users to log in and managing tokens transparently. Check your specific client's documentation for authentication support details.
  </FAQItem>

  <FAQItem question="How do I test MCP authentication locally?">
    During development, you can test authentication by running your MCP server locally and connecting with a client that supports OAuth. Most auth plugins support localhost redirect URIs for development. You can also use tools like MCPJam or Postman MCP Client to test the OAuth flow and verify token handling before deploying.
  </FAQItem>

  <FAQItem question="How do I debug MCP authentication issues?">
    Common debugging steps include: checking server logs for token validation errors, verifying your environment variables are set correctly, ensuring redirect URIs match exactly between your client and auth provider configuration, and confirming your auth provider's dashboard shows the OAuth application is properly configured. Most auth plugins provide detailed error messages that indicate the specific issue.
  </FAQItem>

  <FAQItem question="How do I implement role-based access control (RBAC) in MCP?">
    MCP authentication provides the user's identity, but authorization logic lives in your tool handlers. After validating the access token, extract the user's role from your database or the token claims. Then check permissions before executing sensitive operations. For example, you might allow all authenticated users to read data but restrict write operations to admin roles. Consider using scopes for coarse-grained permissions and roles for fine-grained access within your application.
  </FAQItem>

  <FAQItem question="How do I revoke access tokens?">
    Token revocation depends on your authorization server. Most OAuth providers support a revocation endpoint where you can invalidate tokens before they expire. For immediate revocation, maintain a blocklist of revoked tokens and check it during validation. Short-lived access tokens (15-60 minutes) with longer-lived refresh tokens provide a balance—even if you can't immediately revoke an access token, it will expire soon, and you can revoke the refresh token to prevent new access tokens from being issued.
  </FAQItem>

  <FAQItem question="Can I implement multi-tenant authentication?">
    Yes. Multi-tenant MCP servers can authenticate users from different organizations. Your authorization server should include tenant information in the token claims. During token validation, extract the tenant ID and use it to scope data access and tool permissions. Each tenant can have its own user directory while sharing the same MCP server infrastructure. The discovery mechanism supports tenant-specific authorization server paths like `/.well-known/oauth-authorization-server/tenant-id`.
  </FAQItem>

  <FAQItem question="How do I audit authentication events?">
    Implement logging at key points in the authentication flow: token validation (success and failure), scope checks, and sensitive tool executions. Include the user ID, timestamp, action performed, and result in each log entry. For compliance requirements like GDPR, ensure logs capture consent events and data access. Store audit logs separately from application logs and implement retention policies. Most auth plugins emit events you can hook into for centralized logging.
  </FAQItem>

  <FAQItem question="Can I use SSO or SAML with MCP?">
    Yes. MCP's OAuth 2.1 foundation is compatible with enterprise identity providers that support SSO. Providers like WorkOS and Clerk offer built-in SSO/SAML support, allowing users to authenticate through their corporate identity provider. The MCP client handles the OAuth flow normally—it doesn't need to know whether the authorization server uses SAML federation behind the scenes. This enables seamless integration with enterprise identity systems like Okta, Azure AD, or Google Workspace.
  </FAQItem>

  <FAQItem question="How do refresh tokens work in MCP?">
    Refresh tokens allow clients to obtain new access tokens without user interaction. When the access token expires, the client sends the refresh token to the authorization server's token endpoint to get a fresh access token. This enables long-running sessions without repeated login prompts. Request the `offline_access` scope during authentication to receive a refresh token. Store refresh tokens securely—they're long-lived credentials that can generate new access tokens.
  </FAQItem>
</FAQ>
