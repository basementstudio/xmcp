---
title: "Authentication"
metadataTitle: "MCP Server Authentication Guide | xmcp Documentation"
publishedAt: "2026-01-16"
summary: "Learn how authentication works on MCP servers with human-based interaction."
description: "Secure your MCP server with OAuth 2.1 authentication. Learn about PKCE, JWT tokens, scopes, and token-based access control. Integrate with Better Auth, Clerk, or WorkOS."
displayTitle: "Authentication guide for MCP servers"
---

## Overview

MCP provides authorization capabilities at the transport level, enabling clients to make requests to restricted servers on behalf of resource owners. The authorization mechanism is based on [OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13) and implements several related standards.

## When do you need authentication?

Not every MCP server needs authentication. The decision depends on how your server is deployed and what it exposes.

**HTTP-based MCP servers** that are deployed remotely should implement authentication. When your server is accessible over the network, you need to verify who is making requests before granting access to tools and resources. This applies to servers deployed on platforms like Vercel, AWS, or any cloud provider, as well as self-hosted servers exposed to the internet.

**STDIO-based MCP servers** running locally on a user's machine typically don't need authentication. Since the server runs in the user's own environment with their permissions, the user is implicitly trusted. Instead of OAuth, these servers should retrieve any needed credentials from environment variables or local configuration files.

The key distinction is trust and exposure. A local STDIO server inherits trust from the user's operating system. A remote HTTP server is exposed to the network and must establish trust through authentication before processing requests.

## How MCP authentication works

MCP authentication is built on OAuth 2.1 with mandatory PKCE (Proof Key for Code Exchange). PKCE is a security extension that protects the authorization flow this makes authentication secure even for public clients like desktop apps and CLI tools that cannot safely store long-term secrets.

![MCP Authentication Flow](https://j2fbnka41vq9pfap.public.blob.vercel-storage.com/images/auth-diagram.svg)

### Discovery

When an MCP client first connects to an authenticated server, it needs to discover where and how to authenticate. The client fetches metadata from well-known URLs that describe the authorization server and its capabilities.

The server exposes its authentication requirements at `/.well-known/oauth-protected-resource`, which tells clients where to find the authorization server. The authorization server then provides its endpoints at `/.well-known/oauth-authorization-server`, including where to send users for login and where to exchange tokens.

### Client registration

Before a client can authenticate users, it needs to identify itself to the authorization server. MCP supports three approaches:

**Client ID Metadata Documents** are the recommended approach. Clients host a JSON document at an HTTPS URL that describes their identity, name, and allowed redirect URIs. The URL itself becomes the client ID, eliminating the need for pre-registration.

**Dynamic Client Registration** allows clients to register automatically by making a request to the authorization server. This creates a unique client ID for each installation.

**Pre-registration** is the traditional approach where client credentials are configured in advance, either hardcoded by the developer or entered by the user.

### User authentication

Once the client knows where to authenticate, it redirects the user to the authorization server's login page. The user signs in with their credentials and grants the client permission to access the MCP server on their behalf.

PKCE protects this flow by generating a unique code verifier for each authentication attempt. The client sends a hashed version of this verifier with the authorization request and proves possession of the original when exchanging the authorization code for tokens. This prevents attackers from intercepting and using authorization codes.

### Token-based access

After successful authentication, the client receives an access token. This token is included in every request to the MCP server via the `Authorization: Bearer` header. The server validates the token and extracts user information to authorize the request.

Tokens are bound to the specific MCP server using the `resource` parameter during authentication. This prevents tokens issued for one server from being used to access another, protecting against token confusion attacks.

### Scopes

Scopes define what an access token is allowed to do. They act as permissions that limit the capabilities of a token, even for an authenticated user.

When a client initiates authentication, it requests specific scopes like `read`, `write`, or `admin`. The authorization server includes the granted scopes in the access token. Your MCP server can then check these scopes before allowing certain operations.

Scopes are particularly useful when:
- Different clients need different permission levels
- You want to limit what third-party integrations can do
- Users should be able to grant partial access to their account

The MCP server advertises its supported scopes in the protected resource metadata, and clients can request specific scopes during the authorization flow.

For example, a token with only the `read` scope could access tools that fetch data but would be rejected when trying to use tools that modify data. This provides fine-grained access control beyond simple authentication.

## Security requirements

The MCP specification mandates several security measures:

### PKCE is mandatory

All clients must implement PKCE with the `S256` code challenge method.

### Resource binding

Clients must include the `resource` parameter in authorization and token requests. Servers must validate that tokens were issued specifically for them by checking the audience claim.

### HTTPS everywhere

All authorization server endpoints must use HTTPS.

### Token handling

- Access tokens must be sent via the `Authorization: Bearer` header
- Tokens must never be included in query strings
- Servers should issue short-lived access tokens
- Servers must not pass client tokens through to upstream APIs

## Error responses

- **401**: Authorization required or token invalid/expired
- **403**: Insufficient scopes for the requested operation
- **400**: Malformed authorization request

When a client has insufficient permissions, the server responds with:

## Available auth plugins

xmcp provides plugins that handle all the OAuth complexity for you.

<AuthProviders />

## Choosing an auth plugin

### Better Auth

Best for developers who want full control over their authentication infrastructure.

- Self-hosted with PostgreSQL database
- Built-in authentication UI included
- Email/password and social OAuth support
- Complete ownership of user data

### Clerk

Best for quick setup with minimal configuration.

- Hosted authentication UI
- Organization and team support
- SSO/SAML capabilities
- Managed infrastructure, no database needed

### WorkOS

Best for enterprise applications and B2B SaaS products.

- Hosted authentication UI via AuthKit
- Enterprise SSO and SAML
- Directory sync (SCIM) for user provisioning
- Organization and role management

## FAQ

<FAQ>
  <FAQItem question="What is MCP authentication?">
    MCP authentication is the process of verifying user identity before granting access to an MCP server's tools and resources. It uses OAuth 2.1, the same modern authentication standard used by major platforms, to securely authenticate users through their preferred identity provider.
  </FAQItem>

  <FAQItem question="Do I need authentication for my MCP server?">
    It depends on your deployment. If your MCP server runs over HTTP and is accessible over a network, you should implement authentication to protect sensitive tools and user data. If your server uses STDIO and runs locally on the user's machine, authentication is typically unnecessary since the user is implicitly trusted.
  </FAQItem>

  <FAQItem question="How do MCP clients authenticate with servers?">
    MCP clients use the OAuth 2.1 authorization code flow with PKCE. The client discovers the server's authentication requirements, redirects the user to log in, receives an authorization code, exchanges it for an access token, and includes that token in subsequent requests to the server.
  </FAQItem>

  <FAQItem question="What is Dynamic Client Registration in MCP?">
    Dynamic Client Registration allows MCP clients to automatically register with authorization servers without manual configuration. Instead of pre-registering each client, the server accepts new clients on the fly. MCP also supports Client ID Metadata Documents, where the client hosts its identity information at a URL that becomes its client ID.
  </FAQItem>

  <FAQItem question="Can I use my existing OAuth provider with MCP?">
    Yes. MCP's authentication is based on standard OAuth 2.1 and can work with any compliant authorization server. xmcp provides official plugins for Better Auth (self-hosted), Clerk, and WorkOS, but the protocol is compatible with other OAuth providers that support the required specifications.
  </FAQItem>

  <FAQItem question="What happens when a token expires?">
    When an access token expires, the MCP client receives a `401 Unauthorized` response. The client should then use its refresh token to obtain a new access token without requiring the user to log in again. If the refresh token is also expired, the user must re-authenticate through the full OAuth flow.
  </FAQItem>

  <FAQItem question="How do I protect specific tools with authentication?">
    Once authentication is configured on your MCP server, all tools are protected by default. The server validates the access token before processing any request. Within your tool handlers, you can access the authenticated user's session to implement additional authorization logic, such as restricting certain tools to specific users or roles.
  </FAQItem>

  <FAQItem question="What's the difference between authentication and authorization in MCP?">
    Authentication verifies who the user is through the OAuth flow. Authorization determines what the authenticated user is allowed to do. MCP handles authentication at the transport level, while authorization decisions happen in your tool handlers where you can check the user's session, roles, or permissions before executing operations.
  </FAQItem>

  <FAQItem question="What are scopes in MCP authentication?">
    Scopes are permissions that limit what an access token can do. When authenticating, clients request specific scopes like `read` or `write`. Your MCP server can check these scopes before allowing certain operations, enabling fine-grained access control. For example, you might allow a token with `read` scope to fetch data but reject it when trying to modify data.
  </FAQItem>

  <FAQItem question="What MCP clients support authentication?">
    Most modern MCP clients support OAuth 2.1 authentication, including Claude Desktop, Cursor, and other AI coding assistants. These clients handle the OAuth flow automatically, redirecting users to log in and managing tokens transparently. Check your specific client's documentation for authentication support details.
  </FAQItem>

  <FAQItem question="How do I test MCP authentication locally?">
    During development, you can test authentication by running your MCP server locally and connecting with a client that supports OAuth. Most auth plugins support localhost redirect URIs for development. You can also use tools like Postman or curl to manually test the OAuth flow and verify token handling before deploying.
  </FAQItem>

  <FAQItem question="How do I debug MCP authentication issues?">
    Common debugging steps include: checking server logs for token validation errors, verifying your environment variables are set correctly, ensuring redirect URIs match exactly between your client and auth provider configuration, and confirming your auth provider's dashboard shows the OAuth application is properly configured. Most auth plugins provide detailed error messages that indicate the specific issue.
  </FAQItem>
</FAQ>
