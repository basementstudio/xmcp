---
title: "Everything we shipped so far"
description: "From GPT apps to React components, external MCP clients, and monetization."
category: "changelog"
date: "2025-12-20"
order: 8
textureImage: "/textures/text4.png"
---

xmcp now lets you build GPT apps, render React widgets, connect to external MCPs, monetize and authenticate your tools.

## GPT Apps

Build apps that run directly inside ChatGPT. xmcp integrates with OpenAI's Apps SDK, so your tools can return interactive widgets.

```typescript title="src/tools/counter.tsx"
import { InferSchema, type ToolMetadata } from "xmcp";
import { useState } from "react";
import { z } from "zod";

export const metadata: ToolMetadata = {
  name: "counter",
  description: "Interactive counter widget",
  _meta: {
    openai: {
      toolInvocation: {
        invoking: "Loading counter",
        invoked: "Counter loaded",
      },
      widgetAccessible: true,
      resultCanProduceWidget: true,
    },
  },
};

export const schema = {
  initialCount: z.number().describe("Starting count value"),
};

export default function handler({ initialCount }: InferSchema<typeof schema>) {
  const [count, setCount] = useState(initialCount);

  return (
    <div>
      <h1>Counter: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```

For the full setup guide, check out the [OpenAI Apps SDK integration](/blog/apps-sdk) blog post.

## React Client Components

Tools can return React components that xmcp renders to HTML and serves as widget resources. Enable this by setting `widgetAccessible: true` in your metadata.

```typescript title="src/tools/interactive-todo.tsx"
import { type ToolMetadata } from "xmcp";
import { useState } from "react";

export const metadata: ToolMetadata = {
  name: "interactive-todo",
  description: "Interactive todo list widget",
  _meta: {
    openai: {
      widgetAccessible: true,
      toolInvocation: {
        invoking: "Loading todo list...",
        invoked: "Todo list ready!",
      },
    },
  },
};

export default function InteractiveTodo() {
  const [todos, setTodos] = useState<string[]>([]);
  const [input, setInput] = useState("");

  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, input]);
      setInput("");
    }
  };

  return (
    <div>
      <h2>Todo List</h2>
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Add a todo..."
      />
      <button onClick={addTodo}>Add</button>
      <ul>
        {todos.map((todo, idx) => (
          <li key={idx}>{todo}</li>
        ))}
      </ul>
    </div>
  );
}
```

## Connect to External MCPs

Connect to existing MCP servers and use their tools in yours. Define external clients in `src/clients.ts`:

```typescript title="src/clients.ts"
import { ClientConnections } from "xmcp";

export const clients: ClientConnections = {
  context: {
    url: "https://mcp.context7.com/mcp",
    headers: [
      {
        name: "CONTEXT7_API_KEY",
        env: "CONTEXT7_API_KEY",
      },
    ],
  },
  playwright: {
    npm: "@playwright/mcp",
  },
};
```
<Callout variant="info" icon="info" title="STDIO packages">
STDIO clients like `@playwright/mcp` must be installed in your project.
</Callout>

Then generate typed clients:

```bash
npx @xmcp-dev/cli generate
```

And use them in your tools:

```typescript title="src/tools/browser-navigate.ts"
import { generatedClients } from "../generated/client.index";

export default async function handler({ url }: { url: string }) {
  await generatedClients.playwright.browserNavigate({ url });
  return `Navigated to: ${url}`;
}
```

For the complete guide, see [Connect to external MCPs](/blog/cli-typed-clients).

## Next.js Adapter

Bring xmcp to your existing Next.js application with a single command:

```bash
npx init-xmcp@latest
```

After running it, your project structure should look like this:

```
nextjs-app/
├── app/
│   └── mcp/
│       └── route.ts      # MCP HTTP endpoint
├── tools/
│   └── greet.ts          # Example tool
├── prompts/
│   └── review-code.ts    # Example prompt
├── resources/
│   ├── (config)/
│   │   └── app.ts        # Static resource
│   └── (users)/
│       └── [userId]/
│           └── profile.ts # Dynamic resource
└── xmcp.config.ts        # xmcp configuration
```

The package.json scripts will be modified to run xmcp alongside Next.js, as so is the tsconfig.json will have the paths updated to include the xmcp folder.

For the full setup including authentication, see [Next.js adapter docs](/docs/adapters/nextjs).

## Authentication

xmcp integrates with [Better Auth](https://www.better-auth.com/), adding authentication to your tools with email/password login, OAuth providers, and session management out of the box.

Configure the middleware with your database and auth providers in `src/middleware.ts`:

```typescript title="src/middleware.ts"
import { betterAuthProvider } from "@xmcp-dev/better-auth";
import { Pool } from "pg";

export default betterAuthProvider({
  database: new Pool({
    connectionString: process.env.DATABASE_URL,
  }),
  baseURL: process.env.BETTER_AUTH_BASE_URL,
  secret: process.env.BETTER_AUTH_SECRET,
  providers: {
    emailAndPassword: { enabled: true },
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    },
  },
});
```

Access the authenticated user in your tools with `getBetterAuthSession`:

```typescript title="src/tools/get-user-profile.ts"
import { getBetterAuthSession } from "@xmcp-dev/better-auth";

export default async function getUserProfile() {
  const session = await getBetterAuthSession();
  return `Hello! Your user id is ${session.userId}`;
}
```

For the full setup with database schema and OAuth configuration, see [Integrating Better Auth with xmcp](/blog/better-auth-integration) or the [Better Auth docs](/docs/integrations/better-auth).

## Monetization

Sell products directly from ChatGPT using Stripe checkout. Create tools that list your products and handle purchases.

### Listing products

List the products available for purchase from your Stripe business.

```typescript title="tools/list-products.ts"
import { getProducts } from "@/lib/stripe";
import { ToolMetadata } from "xmcp";

export const metadata: ToolMetadata = {
  name: "list_products",
  description: "List the products available for purchase",
  _meta: {
    openai: {
      widgetAccessible: true,
      resultCanProduceWidget: true,
    },
  },
};

export default async function handler() {
  return {
    structuredContent: { products: await getProducts() },
  };
}
```

### Buying products

Create a checkout session for the selected products and quantities and return the URL to the checkout page.

```typescript title="tools/buy-products.ts"
import { getCheckoutSession } from "@/lib/stripe";
import { ToolMetadata, InferSchema } from "xmcp";
import { z } from "zod";

export const schema = {
  items: z.array(
    z.object({
      priceId: z.string().describe("The Stripe price ID"),
      quantity: z.number().int().min(1).describe("Quantity to purchase"),
    })
  ),
};

export const metadata: ToolMetadata = {
  name: "buy-products",
  description: "Create a checkout link for purchasing products",
  _meta: {
    openai: {
      widgetAccessible: true,
      resultCanProduceWidget: true,
    },
  },
};

export default async function handler({ items }: InferSchema<typeof schema>) {
  const session = await getCheckoutSession(items);

  return {
    content: [{ type: "text", text: `[Complete your purchase](${session.url})` }],
    structuredContent: { checkoutSessionUrl: session.url },
  };
}
```

For the full Stripe implementation with UI components, see [Monetize your GPT apps with Stripe](/blog/apps-monetization).

### Tools suscription based access or usage tracking

Use Polar to validate license keys or track the usage of your tools.

```typescript title="src/tools/premium-tool.ts"
import { headers } from "xmcp/headers";
import { polar } from "../lib/polar";

export default async function handler() {
  const licenseKey = headers()["license-key"];
  const response = await polar.validateLicenseKey(licenseKey as string);

  if (!response.valid) {
    return response.message;
  }

  return "Premium content here";
}
```

For the full Polar setup with usage metering, see [Integrating Polar with xmcp](/blog/polar-integration).

## Other Improvements

- **Rspack migration**: Replaced Webpack with Rspack for faster builds and smaller bundles.
- **CORS configuration**: Configure CORS middleware for cross-domain requests.
- **Structured Content output**: Return structured content alongside UI for richer responses.
- **Project scaffolding**: `create-xmcp-app` sets up everything in one command.

## Contributing

If you have any questions, you can reach out to us on [Discord](https://discord.gg/65ngK7bWEA).