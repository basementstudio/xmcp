---
title: "Everything we shipped so far"
description: "From tools returning React components to Rspack builds, and remote MCP client generation."
category: "changelog"
date: "2025-12-11"
order: 0
previewImage: "/blog/everything-we-shipped-so-far.webp"
featured: true
---

It's been busy months and we've shipped a lot of new features and improvements. Let's recap on them one by one.

## Polar Integration

Managing tool usage and billing is a thing, and we've got you covered with the Polar integration released some months ago. You can add paywalls to your tools and track usage for billing with Polar in a few steps.

```typescript title="src/lib/polar.ts"
import { PolarProvider } from "@xmcp-dev/polar";

export const polar = PolarProvider.getInstance({
  type: "sandbox",
  token: process.env.POLAR_TOKEN!,
  organizationId: process.env.POLAR_ORGANIZATION_ID!,
  productId: process.env.POLAR_PRODUCT_ID!,
});
```

### Paywalling a tool

To paywall a tool, you need to use `validateLicenseKey` method to validate the license key and check if the user has access to the tool.

```typescript title="src/tools/paywall.ts"
import { z } from "zod";
import { type InferSchema, type ToolMetadata } from "xmcp";
import { headers } from "xmcp/headers";
import { polar } from "../lib/polar";

export const schema = {
  name: z.string().describe("The name of the user to greet"),
};

export const metadata: ToolMetadata = {
  name: "greet",
  description: "Greet the user",
  annotations: {
    title: "Greet the user",
    readOnlyHint: true,
    destructiveHint: false,
    idempotentHint: true,
  },
};

export default async function greet({ name }: InferSchema<typeof schema>) {
  const result = `Hello, ${name}!`;
  const licenseKey = headers()["license-key"];
  const response = await polar.validateLicenseKey(licenseKey as string, {
    name: "test_tool_call",
    metadata: { tool_name: "greet", calls: 1 },
  });
  if (!response.valid) {
    return response.message;
  }
  return result;
}
```

## GPT Apps SDK integration

xmcp is fully integrated with the Apps SDK for you to easily build them and whats makes it even better is that xmcp tools are able to return React components directly.

### Counter tool

```typescript title="src/tools/counter.tsx"
import { InferSchema, type ToolMetadata } from "xmcp";
import { useState } from "react";
import { z } from "zod";

export const metadata: ToolMetadata = {
  name: "counter",
  description: "Counter React",
  _meta: {
    openai: {
      toolInvocation: {
        invoking: "Loading counter",
        invoked: "Counter loaded",
      },
      widgetAccessible: true,
      resultCanProduceWidget: true,
    },
  },
};

export const schema = {
  initialCount: z.number().describe("The name of the user to greet"),
};

export default function handler({ initialCount }: InferSchema<typeof schema>) {
  const [count, setCount] = useState(initialCount);

  return (
    <div>
      <h1>Counter: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```

### Weather tool

```typescript title="ui/widget/weather.html"
import { type ToolMetadata } from "xmcp";
import { useState, useEffect } from "react";

export const metadata: ToolMetadata = {
  name: "weather",
  description: "Weather App",
  _meta: {
    openai: {
      toolInvocation: {
        invoking: "Loading weather",
        invoked: "Weather loaded",
      },
      widgetAccessible: true,
      resultCanProduceWidget: true,
    },
  },
};

const cities = {
  "Buenos Aires": { lat: -34.6037, lon: -58.3816 },
  "San Francisco": { lat: 37.7749, lon: -122.4194 },
  Berlin: { lat: 52.52, lon: 13.405 },
  Tokyo: { lat: 35.6762, lon: 139.6503 },
  "New York": { lat: 40.7128, lon: -74.006 },
};

export default function handler() {
  const [selectedCity, setSelectedCity] = useState("Buenos Aires");
  const [weatherData, setWeatherData] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchWeather = async () => {
      setLoading(true);
      setError(null);

      const city = cities[selectedCity as keyof typeof cities];
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${city.lat}&longitude=${city.lon}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m`;

      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error("Failed to fetch weather data");
        }
        const data = await response.json();
        setWeatherData(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
      } finally {
        setLoading(false);
      }
    };

    fetchWeather();
  }, [selectedCity]);

  return (
    <div>
      <h1>Weather App</h1>

      <div>
        <h2>Select a city:</h2>
        {Object.keys(cities).map((city) => (
          <button key={city} onClick={() => setSelectedCity(city)}>
            {city}
          </button>
        ))}
      </div>

      <div>
        <h2>{selectedCity}</h2>

        {loading && <p>Loading...</p>}

        {error && <p>Error: {error}</p>}

        {weatherData && !loading && (
          <div>
            <p>Temperature: {weatherData.current.temperature_2m}Â°C</p>
            <p>Humidity: {weatherData.current.relative_humidity_2m}%</p>
            <p>Wind Speed: {weatherData.current.wind_speed_10m} km/h</p>
          </div>
        )}
      </div>
    </div>
  );
}
```

## Rspack Migration

xmcp was initially built with Webpack and with the v0.5.0 release, we introduced a major performance overhaul by replacing it with Rspack. This was one of our goals, to have a fast and efficient build times.
But not only that, bundle sizes decreased by nearly a third and native type checking was added. This enables us to have a better developer experience and more robust tools. Better for us, better for you.


## Connect to external MCP, discover their tools and use them in yours

One of our most recent released features is the ability to connect to external MCP servers, discover their tools and use them in your workflow. 
You just need a `src/clients.ts` file to define the clients you want to connect, HTTP or STDIO.

```typescript title="src/clients.ts"
import { ClientConnections } from "xmcp";

export const clients: ClientConnections = {
  context: {
    url: "https://mcp.context7.com/mcp",
    headers: [
      {
        name: "CONTEXT7_API_KEY",
        env: "CONTEXT7_API_KEY",
      },
    ],
  },
  playwright: {
    npm: "@playwright/mcp",
  },
};
```

```bash
npx @xmcp-dev/cli generate
```

This will output the typed clients in the `src/generated` directory.

```typescript title="src/tools/external-tool.ts"
import { createRemoteToolClient } from "./generated/client.index";

const client = createRemoteToolClient("external");

export default async function externalTool() {
## Other Improvements

- **OpenAI Apps SDK support**: First-class integration for ChatGPT widgets (see [OpenAI Apps SDK Support](/blog/apps-sdk))
- **Next.js adapter improvements**: Better handler types, auth support, and error handling
- **Structured Content output**: Tools can return structured content alongside UI for richer responses

Polar SH integration
Structured Content output
CORS middleware add preflight flag
structuredContent

## Contributing

Share your feedback and help shape the future of xmcp:
[GitHub](https://github.com/basementstudio/xmcp)

