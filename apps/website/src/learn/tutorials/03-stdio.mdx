---
title: "STDIO Server Tutorial"
description: "Learn to build an MCP server that runs on the STDIO transport and interacts with the local filesystem to perform image processing."
order: 3
---

# STDIO Server Tutorial

Throughout this tutorial, we'll build an MCP server that runs on the STDIO transport and interacts with the local filesystem to perform image processing.

We'll build three image processing tools:

- **Compress** images to reduce file size
- **Convert** between different formats (PNG, JPEG, WebP)
- **Resize** images with various fitting options

You can find the final code for this tutorial [here](https://github.com/basementstudio/xmcp-tutorials/tree/main/stdio).

## Prerequisites

- Node.js 20+ installed
- TypeScript knowledge
- npm account for publishing (optional)

We'll be using Cursor as the MCP client, but you can use any other client you prefer.

## 1. Setting up the project

Let's start by creating a new xmcp project:

```bash
npx create-xmcp-app@latest
```

When prompted, configure your project with these settings:

```
? What is your project named? (my-xmcp-app) image-processor
? Select a package manager:
  npm
  yarn
❯ pnpm
  bun
? Select the transport you want to use: (Use arrow keys)
  HTTP (runs on a server)
❯ STDIO (runs on the user's machine)
```

Your final configuration should look like this:

```
? What is your project named? image-processor
? Select a package manager: pnpm (recommended)
? Select the transport you want to use: STDIO (runs on the user's machine)
```

Navigate to your project and verify the setup:

```bash
cd image-processor
pnpm dev
```

You should see the following output:

```
 XMCP  Starting development mode...
✔ Built STDIO server
✔ Compiled in 185ms
```

This means that the server is running! Let's keep it running in the background so it listens to our changes.

## 2. Connecting to the server

To connect and access the server, we'll need to modify our mcp client JSON config to include the server:

```json
{
  "mcpServers": {
    "stdio": {
      "command": "node",
      "args": ["/path/to/your/project/dist/stdio.js"]
    }
  }
}
```

> With the dev server running, the `dist` folder updates automatically as you make changes. Without it, run `pnpm build` to generate the distribution files. Note that the dev server only watches for changes—your MCP client still needs to run the compiled server with `node`.

To test the connection, go to Cursor's Tools & Integrations panel in Settings and enable it. You should see it detecting one tool—the template `greet.ts` file.

> **Note**: The exact interface depends on your MCP client. In Cursor, this appears in the Tools & Integrations panel.

Before creating our tools, let's configure a few project settings.

## 3. Project configuration

Since we'll be using the `sharp` library for image processing, we need to configure it as an external dependency.

Open `xmcp.config.ts` and add the following. If you set up the project correctly, you should see `stdio: true` in the config.

```typescript
import { type XmcpConfig } from "xmcp";

const config: XmcpConfig = {
  stdio: true,
};

export default config;
```

Next, we'll extend the webpack config to include the `sharp` library as an external dependency.

```typescript
import { type XmcpConfig } from "xmcp";

const config: XmcpConfig = {
  stdio: true,
  webpack(config) {
    (config.externals as string[]).push("sharp");
    return config;
  },
};

export default config;
```

Finally, add `sharp` as an optional dependency in your `package.json`:

```json
{
  // ... rest of the package.json config
  "optionalDependencies": {
    "sharp": "^0.34.3"
  }
}
```

This tells webpack: "Don't bundle Sharp—treat it as an external runtime dependency."

Perfect! Now we can start building the utilities our tools will need.

## 4. Setting up the utilities

Before building our tools, we need utility functions for common image processing tasks. Create `src/utils/image-utils.ts` and let's build each utility:

### 4.1 Path Normalization

First, let's handle file paths properly. This utility ensures that file paths with spaces and special characters work correctly:

```typescript
import { resolve } from "path";

/** Normalize file paths to handle spaces and special characters properly. */
export const normalizePath = (filePath: string): string => {
  // Decode any URL-encoded characters and normalize the path
  try {
    const decoded = decodeURIComponent(filePath);
    return resolve(decoded);
  } catch {
    // If decoding fails, return the original path resolved
    return resolve(filePath);
  }
};
```

This handles URL-encoded characters (like `%20` for spaces) and converts relative paths to absolute paths.

### 4.2 Format Validation

Next, we need to validate and normalize image formats for Sharp compatibility:

```typescript
const supportedImageFormats = ["png", "jpg", "webp", "jpeg"];
type ImageFormats = (typeof supportedImageFormats)[number];
type SupportedSharpFormats = Omit<ImageFormats, "jpg">;

function isSupportedImageFormat(format: string): format is ImageFormats {
  return supportedImageFormats.includes(format as ImageFormats);
}

/** Resolve the sharp format from the input format. */
const resolveSharpFormat = (format: ImageFormats): SupportedSharpFormats => {
  if (format === "jpg") return "jpeg";
  return format;
};

/** Extract and validate the image format from the image path. */
export const getImageFormat = (imagePath: string): SupportedSharpFormats => {
  let originalFormat = imagePath.split(".").pop() as string | undefined;

  if (!originalFormat) {
    throw new Error("The image format is not supported.");
  }

  if (!isSupportedImageFormat(originalFormat)) {
    throw new Error("The image format is not supported.");
  }

  const resolvedFormat = resolveSharpFormat(originalFormat);

  return resolvedFormat;
};
```

This ensures we only process supported formats and normalizes "jpg" to "jpeg" (Sharp's internal format).

### 4.3 File Size Formatting

For user-friendly output, we need to format file sizes in human-readable units:

```typescript
/** Format file size in human readable format. */
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return "0 B";

  const isNegative = bytes < 0;
  const absoluteBytes = Math.abs(bytes);

  const k = 1024;
  const sizes = ["B", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(absoluteBytes) / Math.log(k));
  const formattedSize =
    parseFloat((absoluteBytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];

  return isNegative ? `-${formattedSize}` : formattedSize;
};
```

This converts byte counts to readable formats like "2.5 MB" or "150 KB", handling both positive and negative values for compression comparisons.

### 4.4 Image Processing Setup

Finally, our main utility that orchestrates everything for image processing:

```typescript
import { stat } from "fs/promises";
import sharp from "sharp";

/** Complete image processing setup including file stats and sharp instance. */
export const prepareImageProcessing = async (
  imagePath: string,
  outputPath: string
) => {
  const normalizedImagePath = normalizePath(imagePath);
  const normalizedOutputPath = normalizePath(outputPath);
  const sharpFormat = getImageFormat(normalizedImagePath);

  const originalStats = await stat(normalizedImagePath);
  const originalMetadata = await sharp(normalizedImagePath).metadata();
  const sharpImage = sharp(normalizedImagePath);

  return {
    normalizedImagePath,
    normalizedOutputPath,
    sharpFormat,
    originalStats,
    originalMetadata,
    sharpImage,
  };
};
```

This combines all our utilities into one function that prepares everything needed: normalized paths, format validation, file stats, image metadata, and a Sharp instance ready for processing.

## 5. Crafting the tools

Time to build our first tool! Let's create an image compression tool and walk through the xmcp structure.

### 5.1 Schema Definition

The schema defines and validates the parameters our tool accepts:

```typescript
// Define the schema for tool parameters
export const schema = {
  imagePath: z
    .string()
    .describe(
      "The absolute path to the image to compress. Must include filename and extension."
    ),
  outputPath: z
    .string()
    .describe(
      "The absolute path for the compressed image. Must include filename and extension."
    ),
  quality: z
    .number()
    .min(1)
    .max(100)
    .describe(
      "Compression quality (1-100). Lower values = smaller files but lower quality."
    ),
  progressive: z
    .boolean()
    .optional()
    .default(false)
    .describe("Enable progressive JPEG for web optimization (JPEG only)."),
};
```

To learn more about schema configuration, check out the [Zod documentation](https://zod.dev/).

### 5.2 Tool Metadata

Metadata tells the MCP client how to present and handle our tool:

```typescript
// Define tool metadata
export const metadata: ToolMetadata = {
  name: "compress_image",
  description:
    "Compress images to reduce file size while maintaining visual quality. Supports quality adjustment and progressive JPEG.",
  annotations: {
    title: "Compress Image",
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: false,
  },
};
```

The metadata export is optional but recommended—it helps LLMs discover and understand your tools better.

The `annotations` object provides hints about tool behavior:

- `title`: Human-readable name for the tool
- `readOnlyHint`: Tool doesn't modify its environment
- `destructiveHint`: Tool may perform destructive operations
- `idempotentHint`: Repeated calls with same args have no additional effect
- `openWorldHint`: Tool interacts with external entities

### 5.3 Tool Implementation

Now for the implementation. Create `src/tools/compress-image.ts` with all the necessary imports and logic:

```typescript
// src/tools/compress-image.ts
import { z } from "zod";
import { type ToolMetadata, type InferSchema } from "xmcp";
import { prepareImageProcessing, formatFileSize } from "../utils/image-utils";
import { stat } from "fs/promises";

// ... (schema and metadata from previous sections)

// Tool implementation
export default async function compressImage({
  imagePath,
  outputPath,
  quality,
  progressive = false,
}: InferSchema<typeof schema>) {
  try {
    // Prepare image processing setup
    const {
      normalizedOutputPath,
      sharpFormat,
      originalStats,
      originalMetadata,
      sharpImage,
    } = await prepareImageProcessing(imagePath, outputPath);

    let processedImage = sharpImage;

    // Apply compression settings based on format
    if (sharpFormat === "jpeg") {
      processedImage = processedImage.jpeg({
        quality,
        progressive,
      });
    } else if (sharpFormat === "webp") {
      processedImage = processedImage.webp({ quality });
    } else if (sharpFormat === "png") {
      // PNG doesn't use lossy quality, but we can optimize compression
      processedImage = processedImage.png({
        compressionLevel: Math.floor((100 - quality) / 10), // Convert quality to compression level (0-9)
        progressive: progressive,
      });
    }

    await processedImage.toFile(normalizedOutputPath);

    // Get compressed file info
    const compressedStats = await stat(normalizedOutputPath);

    // Calculate compression results
    const sizeDiff = compressedStats.size - originalStats.size;
    const compressionRatio = ((sizeDiff / originalStats.size) * 100).toFixed(1);

    const resultText =
      sizeDiff < 0
        ? `Saved: ${formatFileSize(-sizeDiff)} (${Math.abs(parseFloat(compressionRatio))}% reduction)`
        : `Increased: ${formatFileSize(sizeDiff)} (+${compressionRatio}% larger)`;

    return `Image compressed successfully!

Original: ${formatFileSize(originalStats.size)} (${originalMetadata.width}×${originalMetadata.height})
Compressed: ${formatFileSize(compressedStats.size)}
${resultText}
Quality: ${quality}%${progressive ? " (Progressive)" : ""}
Format: ${sharpFormat.toUpperCase()}`;
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error occurred";
    return `Error: ${errorMessage}`;
  }
}
```

### 5.4 Format Conversion Tool

Next up: a tool for converting between image formats. Create `src/tools/convert-image.ts`:

```typescript
import { z } from "zod";
import { type ToolMetadata, type InferSchema } from "xmcp";
import sharp from "sharp";
import { prepareImageProcessing, formatFileSize } from "../utils/image-utils";
import { stat } from "fs/promises";

// Define the schema for tool parameters
export const schema = {
  imagePath: z
    .string()
    .describe(
      "The absolute path to the image to convert. Must include filename and extension."
    ),
  outputPath: z
    .string()
    .describe(
      "The absolute path for the converted image. Must include filename and extension."
    ),
  format: z
    .enum(["png", "jpg", "jpeg", "webp"])
    .describe("Target format to convert the image to."),
  quality: z
    .number()
    .min(1)
    .max(100)
    .optional()
    .describe(
      "Quality for lossy formats (JPEG/WebP). If not specified, uses format defaults."
    ),
};

// Define tool metadata
export const metadata: ToolMetadata = {
  name: "convert_image",
  description:
    "Convert images between different formats (PNG, JPEG, WebP). Preserves dimensions and applies format-specific optimizations.",
  annotations: {
    title: "Convert Image Format",
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: false,
  },
};

// Tool implementation
export default async function convertImage({
  imagePath,
  outputPath,
  format,
  quality,
}: InferSchema<typeof schema>) {
  try {
    // Prepare image processing setup
    const {
      normalizedOutputPath,
      sharpFormat,
      originalStats,
      originalMetadata,
      sharpImage,
    } = await prepareImageProcessing(imagePath, outputPath);

    let processedImage = sharpImage;

    // Apply format-specific settings
    if (format === "jpeg" || format === "jpg") {
      processedImage = sharpImage.jpeg({
        quality: quality || 85,
        mozjpeg: true, // Use mozjpeg for better compression
      });
    } else if (format === "webp") {
      processedImage = sharpImage.webp({
        quality: quality || 80,
        effort: 4, // Balanced effort for good compression
      });
    } else if (format === "png") {
      processedImage = sharpImage.png({
        compressionLevel: 6, // Good balance of speed and compression
        adaptiveFiltering: true,
      });
    }

    await processedImage.toFile(normalizedOutputPath);

    // Get converted file info
    const convertedStats = await stat(normalizedOutputPath);
    const convertedMetadata = await sharp(normalizedOutputPath).metadata();

    // Calculate size difference
    const sizeDiff = convertedStats.size - originalStats.size;
    const sizeChangePercent = ((sizeDiff / originalStats.size) * 100).toFixed(
      1
    );

    const sizeChangeText =
      sizeDiff > 0
        ? `+${formatFileSize(sizeDiff)} (+${sizeChangePercent}% larger)`
        : `${formatFileSize(sizeDiff)} (${Math.abs(parseFloat(sizeChangePercent))}% smaller)`;

    return `Image converted successfully!

Original: ${sharpFormat.toUpperCase()} - ${formatFileSize(originalStats.size)} (${originalMetadata.width}×${originalMetadata.height})
Converted: ${format.toUpperCase()} - ${formatFileSize(convertedStats.size)} (${convertedMetadata.width}×${convertedMetadata.height})
Size change: ${sizeChangeText}${quality ? `\nQuality: ${quality}%` : ""}`;
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error occurred";
    return `Error: ${errorMessage}`;
  }
}
```

This tool converts between formats while applying smart optimizations. It uses `mozjpeg` for better JPEG compression and configurable effort levels for WebP. The tool applies sensible quality defaults (85% for JPEG, 80% for WebP) and treats PNG differently from lossy formats. The output shows a detailed before/after comparison.

### 5.5 Image Resize Tool

Finally, let's build our resize tool. Create `src/tools/resize-image.ts`:

```typescript
import { z } from "zod";
import { type ToolMetadata, type InferSchema } from "xmcp";
import sharp, { ResizeOptions } from "sharp";
import { prepareImageProcessing, formatFileSize } from "../utils/image-utils";
import { stat } from "fs/promises";

// Define the schema for tool parameters
export const schema = {
  imagePath: z
    .string()
    .describe(
      "The absolute path to the image to resize. Must include filename and extension."
    ),
  outputPath: z
    .string()
    .describe(
      "The absolute path for the resized image. Must include filename and extension."
    ),
  width: z
    .number()
    .optional()
    .describe(
      "Target width in pixels. If not specified, width will be calculated to maintain aspect ratio."
    ),
  height: z
    .number()
    .optional()
    .describe(
      "Target height in pixels. If not specified, height will be calculated to maintain aspect ratio."
    ),
  fit: z
    .enum(["contain", "cover", "fill", "inside", "outside"])
    .optional()
    .default("contain")
    .describe("How the image should be resized to fit the target dimensions."),
  maintainAspectRatio: z
    .boolean()
    .optional()
    .default(true)
    .describe("Whether to maintain the original aspect ratio when resizing."),
};

// Define tool metadata
export const metadata: ToolMetadata = {
  name: "resize_image",
  description:
    "Resize images to specific dimensions with various fitting options. Can maintain aspect ratio or stretch to exact dimensions.",
  annotations: {
    title: "Resize Image",
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: false,
  },
};

// Tool implementation
export default async function resizeImage({
  imagePath,
  outputPath,
  width,
  height,
  fit,
  maintainAspectRatio = true,
}: InferSchema<typeof schema>) {
  try {
    // Validate that at least width or height is provided
    if (!width && !height) {
      throw new Error("At least width or height must be specified");
    }

    // Prepare image processing setup
    const {
      normalizedOutputPath,
      sharpFormat,
      originalStats,
      originalMetadata,
      sharpImage,
    } = await prepareImageProcessing(imagePath, outputPath);

    // Configure resize options
    const resizeOptions: ResizeOptions = {
      width,
      height,
      fit: maintainAspectRatio ? fit : "fill",
      withoutEnlargement: false, // Allow enlargement
    };

    let processedImage = sharpImage.resize(resizeOptions);

    // Maintain original format and quality
    if (sharpFormat === "jpeg") {
      processedImage = processedImage.jpeg({ quality: 90 });
    } else if (sharpFormat === "webp") {
      processedImage = processedImage.webp({ quality: 90 });
    } else if (sharpFormat === "png") {
      processedImage = processedImage.png({ compressionLevel: 6 });
    }

    await processedImage.toFile(normalizedOutputPath);

    // Get resized file info
    const resizedStats = await stat(normalizedOutputPath);
    const resizedMetadata = await sharp(normalizedOutputPath).metadata();

    // Calculate size difference
    const sizeDiff = resizedStats.size - originalStats.size;
    const sizeChangePercent = ((sizeDiff / originalStats.size) * 100).toFixed(
      1
    );
    const sizeChangeText =
      sizeDiff > 0
        ? `+${formatFileSize(sizeDiff)} (+${sizeChangePercent}% larger)`
        : `${formatFileSize(sizeDiff)} (${Math.abs(parseFloat(sizeChangePercent))}% smaller)`;

    // Calculate scale factors
    const widthScale =
      resizedMetadata.width && originalMetadata.width
        ? ((resizedMetadata.width / originalMetadata.width) * 100).toFixed(1)
        : "N/A";
    const heightScale =
      resizedMetadata.height && originalMetadata.height
        ? ((resizedMetadata.height / originalMetadata.height) * 100).toFixed(1)
        : "N/A";

    return `Image resized successfully!

Original: ${originalMetadata.width}×${originalMetadata.height} - ${formatFileSize(originalStats.size)}
Resized: ${resizedMetadata.width}×${resizedMetadata.height} - ${formatFileSize(resizedStats.size)}
Scale: ${widthScale}% × ${heightScale}%
File size change: ${sizeChangeText}
Fit mode: ${fit}${maintainAspectRatio ? " (aspect ratio maintained)" : " (stretched to fit)"}
Format: ${sharpFormat.toUpperCase()}`;
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error occurred";
    return `Error: ${errorMessage}`;
  }
}
```

This tool offers flexible resizing with smart dimension handling. Specify width, height, or both—missing dimensions are calculated to maintain aspect ratios. The fit modes work as follows:

- `contain`: Scales to fit within bounds while maintaining proportions
- `cover`: Scales to fill bounds, potentially cropping content
- `fill`: Stretches to exact dimensions, ignoring aspect ratios
- `inside`: Like contain but prevents enlargement
- `outside`: Like cover but prevents reduction

The tool validates that at least one dimension is specified and provides detailed scale percentage output.

So far we've reached an important milestone! But everything we've built only works locally. What if you want to make this publicly accessible?

## 6. Publishing the server

Publishing your server is straightforward—just publish it to npm like any other package.

You can read more about [publishing to npm here](https://docs.npmjs.com/cli/v10/commands/npm-publish).

Once published, update your MCP client configuration:

```json
{
  "mcpServers": {
    "mcp-image-processing": {
      "command": "npx",
      "args": ["mcp-image-processing"]
    }
  }
}
```

That's it! Your image processing server is now publicly available and installable via npm.

## What's next?

- Learn how to build an MCP server over HTTP
