import {
  McpServer,
  ResourceTemplate,
} from "@modelcontextprotocol/sdk/server/mcp";
import { ReadResourceResult } from "@modelcontextprotocol/sdk/types";
import { ResourceFile } from "./server";
import { isZodRawShape, pathToName } from "./tools";
import { ZodRawShape } from "zod/v3";
import { transformResourceHandler } from "./transformers/resource";
import { composeUriFromPath } from "./utils/resource-uri-composer";
import { ResourceMetadata } from "@/types/resource";
import { flattenMeta } from "./ui/flatten-meta";
import { generateUIHTML } from "./react/generate-html";
import { pathToToolNameMd5, pathToToolNameDjb2 } from "./path-to-tool-name";
import { uIResourceRegistry } from "./ext-apps-registry";

// Client bundles can be injected at compile time for Cloudflare Workers
// This variable is defined by DefinePlugin at compile time
declare const INJECTED_CLIENT_BUNDLES:
  | Record<string, { js: string; css?: string }>
  | undefined;

declare const IS_CLOUDFLARE: boolean;

/**
 * Get the appropriate pathToToolName function based on runtime environment.
 * - For Cloudflare (INJECTED_CLIENT_BUNDLES defined): Use djb2 hash
 * - For Node.js: Use MD5 hash (backwards compatible)
 */
function pathToToolName(path: string): string {
  // Cloudflare mode: use djb2 hash (bundles were named with djb2 at compile time)
  if (IS_CLOUDFLARE) {
    return pathToToolNameDjb2(path);
  }
  // Node.js mode: use MD5 hash (backwards compatible)
  return pathToToolNameMd5(path);
}

/**
 * Get a client bundle by name.
 * For Cloudflare Workers, bundles are injected at compile time.
 * For Node.js, bundles are read from the filesystem at runtime.
 */
function getClientBundle(
  bundleName: string
): { js: string; css?: string } | null {
  // Cloudflare mode: use injected bundles
  if (INJECTED_CLIENT_BUNDLES) {
    return INJECTED_CLIENT_BUNDLES[bundleName] || null;
  }

  // Node.js mode: read from filesystem
  if (!IS_CLOUDFLARE) {
    try {
      // Dynamic import to avoid bundling fs in Cloudflare
      const fs = require("fs");
      const path = require("path");

      const searchRoots = [
        path.join(process.cwd(), "dist", "client"),
        path.join(process.cwd(), "client"),
      ];

      for (const root of searchRoots) {
        const jsCandidate = path.join(root, `${bundleName}.bundle.js`);
        const cssCandidate = path.join(root, `${bundleName}.bundle.css`);

        if (fs.existsSync(jsCandidate)) {
          const js = fs.readFileSync(jsCandidate, "utf-8");
          let css: string | undefined;

          if (fs.existsSync(cssCandidate)) {
            css = fs.readFileSync(cssCandidate, "utf-8");
          }

          return { js, css };
        }
      }
    } catch {
      // fs not available or file not found
    }
  }

  return null;
}

/** Loads resources and injects them into the server */
export function addResourcesToServer(
  server: McpServer,
  resourcesModules: Map<string, ResourceFile>
): McpServer {
  const autoGeneratedResources = [...uIResourceRegistry.getAll()];

  autoGeneratedResources.forEach(([_, autoResource]) => {
    const resourceMimeType = autoResource.mimeType || "text/html;profile=mcp-app";
    // Flatten resource metadata for MCP protocol
    const flattenedResourceMeta = autoResource?._meta
      ? flattenMeta(autoResource._meta)
      : undefined;
    const resourceConfig: ResourceMetadata = {
      name: autoResource.name,
      description: `Auto-generated resource for ${autoResource.name} tool`,
      mimeType: autoResource.mimeType,
      _meta: flattenedResourceMeta,
    };

    // Transform the handler to serve HTML from the tool handler
    const transformedHandler = async (
      uri: URL,
      extra: any
    ): Promise<ReadResourceResult> => {
      if (autoResource.mimeType && autoResource.toolPath) {
        try {
          const bundleName = pathToToolName(autoResource.toolPath);
          const bundle = getClientBundle(bundleName);

          if (!bundle) {
            throw new Error(
              `React client bundle not found for "${autoResource.name}" (bundle: "${bundleName}").\n` +
                `React tool bundles are generated automatically when you run "xmcp build" (or "xmcp dev").\n` +
                `Please re-run the build so the framework can regenerate the bundle.`
            );
          }

          const clientCode = bundle.js;
          const clientCss = bundle.css;

          const fullHTML = generateUIHTML(clientCode, clientCss);

          return {
            contents: [
              {
                uri: autoResource.uri,
                text: fullHTML,
                mimeType: resourceMimeType,
                _meta: autoResource._meta,
              },
            ],
          };
        } catch (error) {
          console.error(`React failed for ${autoResource.name}:`, error);
          throw error;
        }
      }

      // NON-React PATH: Original behavior (backward compatible)
      // Call the original tool handler to get the HTML content
      let response = autoResource.handler({}, extra);
      if (response instanceof Promise) {
        response = await response;
      }

      // If the tool returns a string (HTML), serve it directly
      if (typeof response === "string") {
        return {
          contents: [
            {
              uri: autoResource.uri,
              text: response,
              mimeType: resourceMimeType,
              _meta: autoResource._meta,
            },
          ],
        };
      }

      // If the tool returns { _meta: ... }, return empty HTML
      if (
        response &&
        typeof response === "object" &&
        "_meta" in response &&
        !("content" in response)
      ) {
        return {
          contents: [
            {
              uri: autoResource.uri,
              text: "",
              mimeType: resourceMimeType,
              _meta: autoResource._meta,
            },
          ],
        };
      }

      // If the tool returns CallToolResult with content array
      if (
        response &&
        typeof response === "object" &&
        "content" in response &&
        Array.isArray(response.content)
      ) {
        const textContent = response.content.find(
          (item: any) => item.type === "text"
        );
        if (
          textContent &&
          textContent.type === "text" &&
          typeof textContent.text === "string"
        ) {
          return {
            contents: [
              {
                uri: autoResource.uri,
                text: textContent.text,
                mimeType: resourceMimeType,
                _meta: autoResource._meta,
              },
            ],
          };
        }
      }

      // Fallback: return empty HTML
      return {
        contents: [
          {
            uri: autoResource.uri,
            text: "",
            mimeType: resourceMimeType,
            _meta: autoResource._meta,
          },
        ],
      };
    };

    // Register as a direct resource
    server.registerResource(
      autoResource.name,
      autoResource.uri,
      resourceConfig,
      transformedHandler
    );
  });

  // Then, register manual resources as before
  resourcesModules.forEach((resourceModule, path) => {
    const defaultName = pathToName(path);

    const resourceConfig: ResourceMetadata = {
      name: defaultName,
      description: "No description provided",
    };

    const { default: handler, metadata, schema } = resourceModule;

    if (typeof metadata === "object" && metadata !== null) {
      Object.assign(resourceConfig, metadata);
    }

    let resourceSchema: ZodRawShape = {};
    if (isZodRawShape(schema)) {
      resourceSchema = schema;
    } else if (schema !== undefined && schema !== null) {
      console.warn(
        `Invalid schema for resource "${resourceConfig.name}" at ${path}. Expected Record<string, z.ZodType>`
      );
    }

    const resourceInfo = composeUriFromPath(path);

    if (!resourceInfo) {
      console.warn(
        `Skipping resource "${resourceConfig.name}" at ${path}: Invalid file path format`
      );
      return;
    }

    // Construct URI based on mimeType
    let uri = resourceInfo.uriTemplate;
    if (resourceConfig.mimeType && resourceConfig.mimeType.includes("html")) {
      // Add .html extension if mimeType contains "html"
      uri = uri.endsWith(".html") ? uri : `${uri}.html`;
    }

    const transformedHandler = transformResourceHandler(
      handler,
      path,
      resourceSchema
    );

    if (resourceInfo.type === "direct") {
      // register as a direct resource (static composed URI)
      server.registerResource(
        resourceConfig.name as string,
        uri,
        resourceConfig,
        transformedHandler
      );
    } else {
      // register as a resource template (dynamic URI with parameters)
      const resourceTemplate = new ResourceTemplate(uri, {
        list: undefined,
      });

      // create template callback that directly uses variables instead of re-parsing URI
      // this is a wrapper over the transformed handler
      // would be nice to have a modelling layer + assertion to handle this
      const templateCallback = async (uri: URL, variables: any, extra: any) => {
        // validate parameters against schema
        const validatedParams: Record<string, any> = {};
        for (const paramName of resourceInfo.parameters) {
          const paramValue = variables[paramName];
          const paramSchema = resourceSchema[paramName];

          if (paramValue === undefined) {
            // throw a nice hint error
            throw new Error(
              `Missing required parameter: ${paramName}. Available variables: ${Object.keys(variables)}`
            );
          }

          if (paramSchema) {
            validatedParams[paramName] = paramSchema.parse(paramValue);
          } else {
            validatedParams[paramName] = paramValue;
          }
        }

        let response = handler(validatedParams, extra);
        if (response instanceof Promise) response = await response;

        return typeof response === "string"
          ? { contents: [{ uri: uri.href, text: response }] }
          : response;
      };

      server.registerResource(
        resourceConfig.name as string,
        resourceTemplate,
        resourceConfig,
        templateCallback
      );
    }
  });

  return server;
}
