import {
  McpServer,
  ResourceTemplate,
} from "@modelcontextprotocol/sdk/server/mcp";
import { ReadResourceResult } from "@modelcontextprotocol/sdk/types";
import { ResourceFile } from "./server";
import { isZodRawShape, pathToName } from "./tools";
import { ZodRawShape } from "zod/v3";
import { transformResourceHandler } from "./transformers/resource";
import { composeUriFromPath } from "./utils/resource-uri-composer";
import { ResourceMetadata } from "@/types/resource";
import { openAIResourceRegistry } from "./openai-resource-registry";
import { flattenMeta } from "./openai/flatten-meta";
import fs from "fs";
import path from "path";
import { generateOpenAIHTML, generateUIHTML } from "./react/generate-html";
import { pathToToolName } from "@/compiler/utils/path-utils";
import { uIResourceRegistry } from "./ext-apps-registry";

/** Loads resources and injects them into the server */
export function addResourcesToServer(
  server: McpServer,
  resourcesModules: Map<string, ResourceFile>
): McpServer {
  // register auto generated resources from openai tools
  const autoGeneratedResources = [
    ...openAIResourceRegistry.getAll(),
    ...uIResourceRegistry.getAll(),
  ];

  autoGeneratedResources.forEach(([_, autoResource]) => {
    // Flatten resource metadata for MCP protocol
    const flattenedResourceMeta = autoResource?._meta
      ? flattenMeta(autoResource._meta)
      : undefined;
    const resourceConfig: ResourceMetadata = {
      name: autoResource.name,
      description: `Auto-generated resource for ${autoResource.name} tool`,
      mimeType: autoResource.mimeType,
      _meta: flattenedResourceMeta,
    };

    // Transform the handler to serve HTML from the tool handler
    const transformedHandler = async (
      uri: URL,
      extra: any
    ): Promise<ReadResourceResult> => {
      if (autoResource.mimeType && autoResource.toolPath) {
        try {
          let clientCode: string | undefined;
          let clientCss: string | undefined;

          const bundleName = pathToToolName(autoResource.toolPath);

          const searchRoots = [
            path.join(process.cwd(), "dist", "client"),
            path.join(process.cwd(), "client"),
          ];
          const attemptedPaths: string[] = [];

          for (const root of searchRoots) {
            const candidate = path.join(root, `${bundleName}.bundle.js`);
            const cssCandidate = path.join(root, `${bundleName}.bundle.css`);
            attemptedPaths.push(candidate);

            if (fs.existsSync(candidate)) {
              clientCode = fs.readFileSync(candidate, "utf-8");

              if (fs.existsSync(cssCandidate)) {
                clientCss = fs.readFileSync(cssCandidate, "utf-8");
              }
              break;
            }
          }

          if (!clientCode) {
            const formattedPaths = attemptedPaths
              .map((p) => `  - ${p}`)
              .join("\n");
            throw new Error(
              `React client bundle not found for "${autoResource.name}" (bundle: "${bundleName}").\n` +
                `Expected to find it on filesystem at one of:\n${formattedPaths}\n` +
                `React tool bundles are generated automatically when you run "xmcp build" (or "xmcp dev").\n` +
                `Please re-run the build so the framework can regenerate the bundle.`
            );
          }

          const isMCPApp =
            autoResource.mimeType === "text/html;profile=mcp-app";
          const fullHTML = isMCPApp
            ? generateUIHTML(clientCode, clientCss)
            : generateOpenAIHTML(clientCode, clientCss);

          return {
            contents: [
              {
                uri: autoResource.uri,
                text: fullHTML,
                mimeType: autoResource.mimeType,
                _meta: autoResource._meta,
              },
            ],
          };
        } catch (error) {
          console.error(`React failed for ${autoResource.name}:`, error);
          throw error;
        }
      }

      // NON-React PATH: Original behavior (backward compatible)
      // Call the original tool handler to get the HTML content
      let response = autoResource.handler({}, extra);
      if (response instanceof Promise) {
        response = await response;
      }

      // If the tool returns a string (HTML), serve it directly
      if (typeof response === "string") {
        return {
          contents: [
            {
              uri: autoResource.uri,
              text: response,
            },
          ],
        };
      }

      // If the tool returns { _meta: ... }, return empty HTML
      // (OpenAI handles the rendering)
      if (
        response &&
        typeof response === "object" &&
        "_meta" in response &&
        !("content" in response)
      ) {
        return {
          contents: [
            {
              uri: autoResource.uri,
              text: "",
            },
          ],
        };
      }

      // If the tool returns CallToolResult with content array
      if (
        response &&
        typeof response === "object" &&
        "content" in response &&
        Array.isArray(response.content)
      ) {
        const textContent = response.content.find(
          (item: any) => item.type === "text"
        );
        if (
          textContent &&
          textContent.type === "text" &&
          typeof textContent.text === "string"
        ) {
          return {
            contents: [
              {
                uri: autoResource.uri,
                text: textContent.text,
              },
            ],
          };
        }
      }

      // Fallback: return empty HTML
      return {
        contents: [
          {
            uri: autoResource.uri,
            text: "",
          },
        ],
      };
    };

    // Register as a direct resource
    server.registerResource(
      autoResource.name,
      autoResource.uri,
      resourceConfig,
      transformedHandler
    );
  });

  // Then, register manual resources as before
  resourcesModules.forEach((resourceModule, path) => {
    const defaultName = pathToName(path);

    const resourceConfig: ResourceMetadata = {
      name: defaultName,
      description: "No description provided",
    };

    const { default: handler, metadata, schema } = resourceModule;

    if (typeof metadata === "object" && metadata !== null) {
      Object.assign(resourceConfig, metadata);
    }

    let resourceSchema: ZodRawShape = {};
    if (isZodRawShape(schema)) {
      resourceSchema = schema;
    } else if (schema !== undefined && schema !== null) {
      console.warn(
        `Invalid schema for resource "${resourceConfig.name}" at ${path}. Expected Record<string, z.ZodType>`
      );
    }

    const resourceInfo = composeUriFromPath(path);

    if (!resourceInfo) {
      console.warn(
        `Skipping resource "${resourceConfig.name}" at ${path}: Invalid file path format`
      );
      return;
    }

    // Construct URI based on mimeType
    let uri = resourceInfo.uriTemplate;
    if (resourceConfig.mimeType && resourceConfig.mimeType.includes("html")) {
      // Add .html extension if mimeType contains "html"
      uri = uri.endsWith(".html") ? uri : `${uri}.html`;
    }

    const transformedHandler = transformResourceHandler(
      handler,
      path,
      resourceSchema
    );

    if (resourceInfo.type === "direct") {
      // register as a direct resource (static composed URI)
      server.registerResource(
        resourceConfig.name as string,
        uri,
        resourceConfig,
        transformedHandler
      );
    } else {
      // register as a resource template (dynamic URI with parameters)
      const resourceTemplate = new ResourceTemplate(uri, {
        list: undefined,
      });

      // create template callback that directly uses variables instead of re-parsing URI
      // this is a wrapper over the transformed handler
      // would be nice to have a modelling layer + assertion to handle this
      const templateCallback = async (uri: URL, variables: any, extra: any) => {
        // validate parameters against schema
        const validatedParams: Record<string, any> = {};
        for (const paramName of resourceInfo.parameters) {
          const paramValue = variables[paramName];
          const paramSchema = resourceSchema[paramName];

          if (paramValue === undefined) {
            // throw a nice hint error
            throw new Error(
              `Missing required parameter: ${paramName}. Available variables: ${Object.keys(variables)}`
            );
          }

          if (paramSchema) {
            validatedParams[paramName] = paramSchema.parse(paramValue);
          } else {
            validatedParams[paramName] = paramValue;
          }
        }

        let response = handler(validatedParams, extra);
        if (response instanceof Promise) response = await response;

        return typeof response === "string"
          ? { contents: [{ uri: uri.href, text: response }] }
          : response;
      };

      server.registerResource(
        resourceConfig.name as string,
        resourceTemplate,
        resourceConfig,
        templateCallback
      );
    }
  });

  return server;
}
