import {
  McpServer,
  ResourceTemplate,
} from "@modelcontextprotocol/sdk/server/mcp";
import { ReadResourceResult } from "@modelcontextprotocol/sdk/types";
import { ResourceFile } from "./server";
import { isZodRawShape, pathToName } from "./tools";
import { ZodRawShape } from "zod";
import { transformResourceHandler } from "./transformers/resource";
import { composeUriFromPath } from "./utils/resource-uri-composer";
import { ResourceMetadata } from "@/types/resource";
import { openAIResourceRegistry } from "./openai-resource-registry";
import fs from "fs";
import path from "path";

/** Loads resources and injects them into the server */
export function addResourcesToServer(
  server: McpServer,
  resourcesModules: Map<string, ResourceFile>,
  ssrEnabled: boolean = false
): McpServer {
  // First, register auto-generated resources from OpenAI tools
  const autoGeneratedResources = openAIResourceRegistry.getAll();
  autoGeneratedResources.forEach((autoResource) => {
    const resourceConfig: ResourceMetadata = {
      name: autoResource.name,
      description: `Auto-generated resource for ${autoResource.name} tool`,
      mimeType: "text/html+skybridge",
    };

    // Transform the handler to serve HTML from the tool handler
    const transformedHandler = async (
      uri: URL,
      extra: any
    ): Promise<ReadResourceResult> => {
      if (
        ssrEnabled &&
        autoResource.isReactComponent &&
        autoResource.toolPath
      ) {
        try {
          // Dynamically import SSR dependencies only when needed
          // Use eval to prevent webpack from analyzing these requires
          const dynamicRequire = eval("require");

          // Check if React is available
          let renderToString, createElement;
          try {
            renderToString = dynamicRequire("react-dom/server").renderToString;
            createElement = dynamicRequire("react").createElement;
          } catch (error) {
            throw new Error(
              `SSR is enabled but React is not installed.\n` +
              `Please install React to use SSR:\n` +
              `  npm install react react-dom\n` +
              `Or disable SSR in xmcp.config.ts`
            );
          }
          const { generateHTMLWithSSR } = dynamicRequire(
            "xmcp/dist/runtime/utils/ssr/bundler"
          );

          const serverHTML = renderToString(
            createElement(autoResource.handler as any)
          );

          const bundlePath = path.join(
            process.cwd(),
            "dist/client",
            `${autoResource.name}.bundle.js`
          );

          if (!fs.existsSync(bundlePath)) {
            throw new Error(
              `SSR client bundle not found for "${autoResource.name}".\n` +
                `Expected at: ${bundlePath}\n` +
                `Make sure you ran "xmcp build" with SSR enabled before starting the server.`
            );
          }

          const clientCode = fs.readFileSync(bundlePath, "utf-8");

          const fullHTML = generateHTMLWithSSR(serverHTML, clientCode);

          return {
            contents: [
              {
                uri: autoResource.uri,
                text: fullHTML,
              },
            ],
          };
        } catch (error) {
          console.error(`SSR failed for ${autoResource.name}:`, error);
          throw error; // Don't fallback, fail clearly with helpful error
        }
      }

      // NON-SSR PATH: Original behavior (backward compatible)
      // Call the original tool handler to get the HTML content
      let response = autoResource.handler({}, extra);
      if (response instanceof Promise) {
        response = await response;
      }

      // If the tool returns a string (HTML), serve it directly
      if (typeof response === "string") {
        return {
          contents: [
            {
              uri: autoResource.uri,
              text: response,
            },
          ],
        };
      }

      // If the tool returns { _meta: ... }, return empty HTML
      // (OpenAI handles the rendering)
      if (
        response &&
        typeof response === "object" &&
        "_meta" in response &&
        !("content" in response)
      ) {
        return {
          contents: [
            {
              uri: autoResource.uri,
              text: "",
            },
          ],
        };
      }

      // If the tool returns CallToolResult with content array
      if (
        response &&
        typeof response === "object" &&
        "content" in response &&
        Array.isArray(response.content)
      ) {
        const textContent = response.content.find(
          (item: any) => item.type === "text"
        );
        if (
          textContent &&
          textContent.text &&
          typeof textContent.text === "string"
        ) {
          return {
            contents: [
              {
                uri: autoResource.uri,
                text: textContent.text,
              },
            ],
          };
        }
      }

      // Fallback: return empty HTML
      return {
        contents: [
          {
            uri: autoResource.uri,
            text: "",
          },
        ],
      };
    };

    // Register as a direct resource
    server.registerResource(
      autoResource.name,
      autoResource.uri,
      resourceConfig,
      transformedHandler
    );
  });

  // Then, register manual resources as before
  resourcesModules.forEach((resourceModule, path) => {
    const defaultName = pathToName(path);

    const resourceConfig: ResourceMetadata = {
      name: defaultName,
      description: "No description provided",
    };

    const { default: handler, metadata, schema } = resourceModule;

    if (typeof metadata === "object" && metadata !== null) {
      Object.assign(resourceConfig, metadata);
    }

    let resourceSchema: ZodRawShape = {};
    if (isZodRawShape(schema)) {
      resourceSchema = schema;
    } else if (schema !== undefined && schema !== null) {
      console.warn(
        `Invalid schema for resource "${resourceConfig.name}" at ${path}. Expected Record<string, z.ZodType>`
      );
    }

    const resourceInfo = composeUriFromPath(path);

    if (!resourceInfo) {
      console.warn(
        `Skipping resource "${resourceConfig.name}" at ${path}: Invalid file path format`
      );
      return;
    }

    // Construct URI based on mimeType
    let uri = resourceInfo.uriTemplate;
    if (resourceConfig.mimeType && resourceConfig.mimeType.includes("html")) {
      // Add .html extension if mimeType contains "html"
      uri = uri.endsWith(".html") ? uri : `${uri}.html`;
    }

    const transformedHandler = transformResourceHandler(
      handler,
      path,
      resourceSchema
    );

    if (resourceInfo.type === "direct") {
      // register as a direct resource (static composed URI)
      server.registerResource(
        resourceConfig.name as string,
        uri,
        resourceConfig,
        transformedHandler
      );
    } else {
      // register as a resource template (dynamic URI with parameters)
      const resourceTemplate = new ResourceTemplate(uri, {
        list: undefined,
      });

      // create template callback that directly uses variables instead of re-parsing URI
      // this is a wrapper over the transformed handler
      // would be nice to have a modelling layer + assertion to handle this
      const templateCallback = async (uri: URL, variables: any, extra: any) => {
        // validate parameters against schema
        const validatedParams: Record<string, any> = {};
        for (const paramName of resourceInfo.parameters) {
          const paramValue = variables[paramName];
          const paramSchema = resourceSchema[paramName];

          if (paramValue === undefined) {
            // throw a nice hint error
            throw new Error(
              `Missing required parameter: ${paramName}. Available variables: ${Object.keys(variables)}`
            );
          }

          if (paramSchema) {
            validatedParams[paramName] = paramSchema.parse(paramValue);
          } else {
            validatedParams[paramName] = paramValue;
          }
        }

        let response = handler(validatedParams, extra);
        if (response instanceof Promise) response = await response;

        return typeof response === "string"
          ? { contents: [{ uri: uri.href, text: response }] }
          : response;
      };

      server.registerResource(
        resourceConfig.name as string,
        resourceTemplate,
        resourceConfig,
        templateCallback
      );
    }
  });

  return server;
}
