import {
  McpServer,
  ResourceTemplate,
} from "@modelcontextprotocol/sdk/server/mcp";
import { ReadResourceResult } from "@modelcontextprotocol/sdk/types";
import { ResourceFile } from "./server";
import { isZodRawShape, pathToName } from "./tools";
import { ZodRawShape } from "zod";
import { transformResourceHandler } from "./transformers/resource";
import { composeUriFromPath } from "./utils/resource-uri-composer";
import { ResourceMetadata } from "@/types/resource";
import { openAIResourceRegistry } from "./openai-resource-registry";
import { flattenMeta } from "./openai/flatten-meta";
import fs from "fs";
import path from "path";
import { generateHTML } from "./react/generate-html";
import { CLIENT_BUNDLE_PLACEHOLDER } from "@/constants/client-bundle-placeholder";

const INJECTED_CLIENT_BUNDLES = CLIENT_BUNDLE_PLACEHOLDER as unknown as
  | Record<string, string>
  | undefined;

/** Loads resources and injects them into the server */
export function addResourcesToServer(
  server: McpServer,
  resourcesModules: Map<string, ResourceFile>
): McpServer {
  // register auto generated resources from openai tools
  const autoGeneratedResources = openAIResourceRegistry.getAll();
  autoGeneratedResources.forEach((autoResource) => {
    // Flatten resource metadata for MCP protocol
    const flattenedResourceMeta = flattenMeta(autoResource.resourceMeta);

    const resourceConfig: ResourceMetadata = {
      name: autoResource.name,
      description: `Auto-generated resource for ${autoResource.name} tool`,
      mimeType: "text/html+skybridge",
      _meta: flattenedResourceMeta, // Apply flattened resource-specific metadata
    };

    // Transform the handler to serve HTML from the tool handler
    const transformedHandler = async (
      uri: URL,
      extra: any
    ): Promise<ReadResourceResult> => {
      if (autoResource.isReactComponent && autoResource.toolPath) {
        try {
          let clientCode: string | undefined;

          // Priority 1: Use injected bundles (reliable in Lambda/serverless)
          clientCode = INJECTED_CLIENT_BUNDLES?.[autoResource.name];

          // Priority 2: Fallback to filesystem (for local development)
          if (!clientCode) {
            const searchRoots = [
              path.join(process.cwd(), "dist", "client"),
              path.join(process.cwd(), "client"),
            ];
            const attemptedPaths: string[] = [];

            for (const root of searchRoots) {
              const candidate = path.join(
                root,
                `${autoResource.name}.bundle.js`
              );
              attemptedPaths.push(candidate);

              if (fs.existsSync(candidate)) {
                clientCode = fs.readFileSync(candidate, "utf-8");
                break;
              }
            }

            if (!clientCode) {
              const formattedPaths = attemptedPaths
                .map((p) => `  - ${p}`)
                .join("\n");
              throw new Error(
                `React client bundle not found for "${autoResource.name}".\n` +
                  `Expected to find it either:\n` +
                  `  1. Injected in the bundle (INJECTED_CLIENT_BUNDLES)\n` +
                  `  2. On filesystem at one of:\n${formattedPaths}\n` +
                  `React tool bundles are generated automatically when you run "xmcp build" (or "xmcp dev").\n` +
                  `Please re-run the build so the framework can regenerate the bundle.`
              );
            }
          }

          // Render empty shell HTML - the client will hydrate with the actual component
          const fullHTML = generateHTML(clientCode);

          return {
            contents: [
              {
                uri: autoResource.uri,
                text: fullHTML,
              },
            ],
          };
        } catch (error) {
          console.error(`React failed for ${autoResource.name}:`, error);
          throw error;
        }
      }

      // NON-React PATH: Original behavior (backward compatible)
      // Call the original tool handler to get the HTML content
      let response = autoResource.handler({}, extra);
      if (response instanceof Promise) {
        response = await response;
      }

      // If the tool returns a string (HTML), serve it directly
      if (typeof response === "string") {
        return {
          contents: [
            {
              uri: autoResource.uri,
              text: response,
            },
          ],
        };
      }

      // If the tool returns { _meta: ... }, return empty HTML
      // (OpenAI handles the rendering)
      if (
        response &&
        typeof response === "object" &&
        "_meta" in response &&
        !("content" in response)
      ) {
        return {
          contents: [
            {
              uri: autoResource.uri,
              text: "",
            },
          ],
        };
      }

      // If the tool returns CallToolResult with content array
      if (
        response &&
        typeof response === "object" &&
        "content" in response &&
        Array.isArray(response.content)
      ) {
        const textContent = response.content.find(
          (item: any) => item.type === "text"
        );
        if (
          textContent &&
          textContent.text &&
          typeof textContent.text === "string"
        ) {
          return {
            contents: [
              {
                uri: autoResource.uri,
                text: textContent.text,
              },
            ],
          };
        }
      }

      // Fallback: return empty HTML
      return {
        contents: [
          {
            uri: autoResource.uri,
            text: "",
          },
        ],
      };
    };

    // Register as a direct resource
    server.registerResource(
      autoResource.name,
      autoResource.uri,
      resourceConfig,
      transformedHandler
    );
  });

  // Then, register manual resources as before
  resourcesModules.forEach((resourceModule, path) => {
    const defaultName = pathToName(path);

    const resourceConfig: ResourceMetadata = {
      name: defaultName,
      description: "No description provided",
    };

    const { default: handler, metadata, schema } = resourceModule;

    if (typeof metadata === "object" && metadata !== null) {
      Object.assign(resourceConfig, metadata);
    }

    let resourceSchema: ZodRawShape = {};
    if (isZodRawShape(schema)) {
      resourceSchema = schema;
    } else if (schema !== undefined && schema !== null) {
      console.warn(
        `Invalid schema for resource "${resourceConfig.name}" at ${path}. Expected Record<string, z.ZodType>`
      );
    }

    const resourceInfo = composeUriFromPath(path);

    if (!resourceInfo) {
      console.warn(
        `Skipping resource "${resourceConfig.name}" at ${path}: Invalid file path format`
      );
      return;
    }

    // Construct URI based on mimeType
    let uri = resourceInfo.uriTemplate;
    if (resourceConfig.mimeType && resourceConfig.mimeType.includes("html")) {
      // Add .html extension if mimeType contains "html"
      uri = uri.endsWith(".html") ? uri : `${uri}.html`;
    }

    const transformedHandler = transformResourceHandler(
      handler,
      path,
      resourceSchema
    );

    if (resourceInfo.type === "direct") {
      // register as a direct resource (static composed URI)
      server.registerResource(
        resourceConfig.name as string,
        uri,
        resourceConfig,
        transformedHandler
      );
    } else {
      // register as a resource template (dynamic URI with parameters)
      const resourceTemplate = new ResourceTemplate(uri, {
        list: undefined,
      });

      // create template callback that directly uses variables instead of re-parsing URI
      // this is a wrapper over the transformed handler
      // would be nice to have a modelling layer + assertion to handle this
      const templateCallback = async (uri: URL, variables: any, extra: any) => {
        // validate parameters against schema
        const validatedParams: Record<string, any> = {};
        for (const paramName of resourceInfo.parameters) {
          const paramValue = variables[paramName];
          const paramSchema = resourceSchema[paramName];

          if (paramValue === undefined) {
            // throw a nice hint error
            throw new Error(
              `Missing required parameter: ${paramName}. Available variables: ${Object.keys(variables)}`
            );
          }

          if (paramSchema) {
            validatedParams[paramName] = paramSchema.parse(paramValue);
          } else {
            validatedParams[paramName] = paramValue;
          }
        }

        let response = handler(validatedParams, extra);
        if (response instanceof Promise) response = await response;

        return typeof response === "string"
          ? { contents: [{ uri: uri.href, text: response }] }
          : response;
      };

      server.registerResource(
        resourceConfig.name as string,
        resourceTemplate,
        resourceConfig,
        templateCallback
      );
    }
  });

  return server;
}
