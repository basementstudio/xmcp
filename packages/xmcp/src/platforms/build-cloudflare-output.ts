import path from "path";
import fs from "fs";

const rootDir = process.cwd();

interface BuildCloudflareOutputOptions {
  log?: boolean;
}

/**
 * Build the Cloudflare Workers output structure.
 * Writes Cloudflare Worker files to the project root:
 * - worker.js
 * - wrangler.jsonc (only if not already present)
 */
async function buildCloudflareOutput(
  options: BuildCloudflareOutputOptions = {}
) {
  const { log = true } = options;
  const outputDir = rootDir;
  const buildDir = path.join(rootDir, ".xmcp", "cloudflare");

  // Check if Cloudflare worker build exists
  const sourceFile = path.join(buildDir, "worker.js");
  if (!fs.existsSync(sourceFile)) {
    throw new Error("Cloudflare build output not found. Run: xmcp build --cf");
  }

  // Copy the bundled worker
  const targetFile = path.join(outputDir, "worker.js");
  fs.copyFileSync(sourceFile, targetFile);

  // Generate wrangler config (only if the user doesn't have one already)
  const wranglerTomlPath = path.join(outputDir, "wrangler.toml");
  const wranglerJsoncPath = path.join(outputDir, "wrangler.jsonc");
  if (!fs.existsSync(wranglerTomlPath) && !fs.existsSync(wranglerJsoncPath)) {
    const projectName = getProjectName();
    const wranglerConfig = generateWranglerConfig(projectName);
    fs.writeFileSync(wranglerJsoncPath, wranglerConfig);
  }

  if (log) {
    console.log("Cloudflare Workers output structure created successfully");
    console.log("");
    console.log("Next steps:");
    console.log("  1. npx wrangler dev       # Test locally");
    console.log("  2. npx wrangler deploy    # Deploy to Cloudflare");
  }
}

/**
 * Get the project name from package.json or directory name.
 */
function getProjectName(): string {
  try {
    const packageJsonPath = path.join(rootDir, "package.json");
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));
      if (packageJson.name) {
        // Sanitize the name for Cloudflare Workers
        return packageJson.name
          .replace(/^@[^/]+\//, "") // Remove scope
          .replace(/[^a-zA-Z0-9-]/g, "-") // Replace invalid chars
          .toLowerCase();
      }
    }
  } catch {
    // Fallback to directory name
  }

  return path
    .basename(rootDir)
    .replace(/[^a-zA-Z0-9-]/g, "-")
    .toLowerCase();
}

/**
 * Generate a wrangler.jsonc configuration file.
 */
function generateWranglerConfig(projectName: string): string {
  const compatibilityDate = new Date().toISOString().split("T")[0];

  // JSONC format: valid JSON with comments and trailing commas allowed
  return `{
  "$schema": "node_modules/wrangler/config-schema.json",
  // Wrangler config generated by: xmcp build --cf
  // Docs: https://developers.cloudflare.com/workers/wrangler/configuration/
  "name": ${JSON.stringify(projectName)},
  "main": "worker.js",
  "compatibility_date": ${JSON.stringify(compatibilityDate)},
  "compatibility_flags": ["nodejs_compat"],

  // Observability (Workers Logs)
  "observability": {
    "enabled": true
  }

  // Uncomment to add environment variables:
  // "vars": {
  //   "MY_VAR": "my-value"
  // },

  // Uncomment to add KV namespaces:
  // "kv_namespaces": [
  //   { "binding": "MY_KV", "id": "your-kv-namespace-id" }
  // ],

  // Uncomment to add D1 databases:
  // "d1_databases": [
  //   { "binding": "MY_DB", "database_name": "my-database", "database_id": "your-database-id" }
  // ]
}
`;
}

export { buildCloudflareOutput };
